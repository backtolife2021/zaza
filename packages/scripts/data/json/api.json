{
  "nvim__buf_redraw_range": {
    "annotations": [],
    "signature": "nvim__buf_redraw_range({buffer}, {first}, {last}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "first"],
      ["Integer", "last"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim__buf_stats": {
    "annotations": [],
    "signature": "nvim__buf_stats({buffer}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim__get_hl_defs": {
    "annotations": [],
    "signature": "nvim__get_hl_defs({ns_id}, {err})",
    "parameters": [
      ["Integer", "ns_id"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim__get_lib_dir": {
    "annotations": [],
    "signature": "nvim__get_lib_dir()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim__get_runtime": {
    "annotations": ["|api-fast|"],
    "signature": "nvim__get_runtime({pat}, {all}, {opts}, {err})",
    "parameters": [
      ["Array", "pat"],
      ["Boolean", "all"],
      ["Dict(runtime) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "pat": "pattern of files to search for",
      "all": "whether to return all matches or only the first",
      "opts": "is_lua: only search lua subdirs"
    },
    "doc": ["Find files in runtime directories"],
    "return": ["list of absolute paths to the found files"],
    "seealso": []
  },
  "nvim__id": {
    "annotations": [],
    "signature": "nvim__id({obj})",
    "parameters": [["Object", "obj"]],
    "parameters_doc": { "obj": "Object to return." },
    "doc": [
      "Returns object given as argument.",
      "This API function is used for testing. One should not rely on\nits presence in plugins."
    ],
    "return": ["its argument."],
    "seealso": []
  },
  "nvim__id_array": {
    "annotations": [],
    "signature": "nvim__id_array({arr})",
    "parameters": [["Array", "arr"]],
    "parameters_doc": { "arr": "Array to return." },
    "doc": [
      "Returns array given as argument.",
      "This API function is used for testing. One should not rely on\nits presence in plugins."
    ],
    "return": ["its argument."],
    "seealso": []
  },
  "nvim__id_dictionary": {
    "annotations": [],
    "signature": "nvim__id_dictionary({dct})",
    "parameters": [["Dictionary", "dct"]],
    "parameters_doc": { "dct": "Dictionary to return." },
    "doc": [
      "Returns dictionary given as argument.",
      "This API function is used for testing. One should not rely on\nits presence in plugins."
    ],
    "return": ["its argument."],
    "seealso": []
  },
  "nvim__id_float": {
    "annotations": [],
    "signature": "nvim__id_float({flt})",
    "parameters": [["Float", "flt"]],
    "parameters_doc": { "flt": "Value to return." },
    "doc": [
      "Returns floating-point value given as argument.",
      "This API function is used for testing. One should not rely on\nits presence in plugins."
    ],
    "return": ["its argument."],
    "seealso": []
  },
  "nvim__inspect_cell": {
    "annotations": [],
    "signature": "nvim__inspect_cell({grid}, {row}, {col}, {err})",
    "parameters": [
      ["Integer", "grid"],
      ["Integer", "row"],
      ["Integer", "col"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim__runtime_inspect": {
    "annotations": [],
    "signature": "nvim__runtime_inspect()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim__screenshot": {
    "annotations": ["|api-fast|"],
    "signature": "nvim__screenshot({path})",
    "parameters": [["String", "path"]],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim__set_hl_ns": {
    "annotations": ["|api-fast|"],
    "signature": "nvim__set_hl_ns({ns_id}, {err})",
    "parameters": [
      ["Integer", "ns_id"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "ns_id": "the namespace to activate" },
    "doc": [
      "Set active namespace for highlights.",
      "NB: this function can be called from async contexts, but the\nsemantics are not yet well-defined. To start with\n|nvim_set_decoration_provider| on_win and on_line callbacks\nare explicitly allowed to change the namespace during a redraw\ncycle."
    ],
    "return": [],
    "seealso": []
  },
  "nvim__stats": {
    "annotations": [],
    "signature": "nvim__stats()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Gets internal stats."],
    "return": ["Map of various internal stats."],
    "seealso": []
  },
  "nvim__unpack": {
    "annotations": ["|api-fast|"],
    "signature": "nvim__unpack({str}, {err})",
    "parameters": [
      ["String", "str"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim_buf_add_highlight": {
    "annotations": [],
    "signature": "nvim_buf_add_highlight({buffer}, {ns_id}, {hl_group}, {line}, {col_start}, {col_end}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "ns_id"],
      ["String", "hl_group"],
      ["Integer", "line"],
      ["Integer", "col_start"],
      ["Integer", "col_end"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "ns_id": "namespace to use or -1 for ungrouped\n                 highlight",
      "hl_group": "Name of the highlight group to use",
      "line": "Line to highlight (zero-indexed)",
      "col_start": "Start of (byte-indexed) column range to\n                 highlight",
      "col_end": "End of (byte-indexed) column range to\n                 highlight, or -1 to highlight to end of line"
    },
    "doc": [
      "Adds a highlight to buffer.",
      "Useful for plugins that dynamically generate highlights to a\nbuffer (like a semantic highlighter or linter). The function\nadds a single highlight to a buffer. Unlike |matchaddpos()|\nhighlights follow changes to line numbering (as lines are\ninserted/removed above the highlighted line), like signs and\nmarks do.",
      "Namespaces are used for batch deletion/updating of a set of\nhighlights. To create a namespace, use\n|nvim_create_namespace()| which returns a namespace id. Pass\nit in to this function as `ns_id` to add highlights to the\nnamespace. All highlights in the same namespace can then be\ncleared with single call to |nvim_buf_clear_namespace()|. If\nthe highlight never will be deleted by an API call, pass\n`ns_id = -1`.",
      "As a shorthand, `ns_id = 0` can be used to create a new\nnamespace for the highlight, the allocated id is then\nreturned. If `hl_group` is the empty string no highlight is\nadded, but a new `ns_id` is still returned. This is supported\nfor backwards compatibility, new code should use\n|nvim_create_namespace()| to create a new empty namespace."
    ],
    "return": ["The ns_id that was used"],
    "seealso": []
  },
  "nvim_buf_attach": {
    "annotations": [],
    "signature": "nvim_buf_attach({buffer}, {send_buffer}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Boolean", "send_buffer"],
      ["DictionaryOf(LuaRef)", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "send_buffer": "True if the initial notification should\n                   contain the whole buffer: first\n                   notification will be\n                   `nvim_buf_lines_event`. Else the first\n                   notification will be\n                   `nvim_buf_changedtick_event`. Not for Lua\n                   callbacks.",
      "opts": "Optional parameters.\n                   • on_lines: Lua callback invoked on change.\n                     Return `true` to detach. Args:\n                     • the string \"lines\"\n                     • buffer handle\n                     • b:changedtick\n                     • first line that changed (zero-indexed)\n                     • last line that was changed\n                     • last line in the updated range\n                     • byte count of previous contents\n                     • deleted_codepoints (if `utf_sizes` is\n                       true)\n                     • deleted_codeunits (if `utf_sizes` is\n                       true)\n\n                   • on_bytes: lua callback invoked on change.\n                     This callback receives more granular\n                     information about the change compared to\n                     on_lines. Return `true` to detach. Args:\n                     • the string \"bytes\"\n                     • buffer handle\n                     • b:changedtick\n                     • start row of the changed text\n                       (zero-indexed)\n                     • start column of the changed text\n                     • byte offset of the changed text (from\n                       the start of the buffer)\n                     • old end row of the changed text\n                     • old end column of the changed text\n                     • old end byte length of the changed text\n                     • new end row of the changed text\n                     • new end column of the changed text\n                     • new end byte length of the changed text\n\n                   • on_changedtick: Lua callback invoked on\n                     changedtick increment without text\n                     change. Args:\n                     • the string \"changedtick\"\n                     • buffer handle\n                     • b:changedtick\n\n                   • on_detach: Lua callback invoked on\n                     detach. Args:\n                     • the string \"detach\"\n                     • buffer handle\n\n                   • on_reload: Lua callback invoked on\n                     reload. The entire buffer content should\n                     be considered changed. Args:\n                     • the string \"reload\"\n                     • buffer handle\n\n                   • utf_sizes: include UTF-32 and UTF-16 size\n                     of the replaced region, as args to\n                     `on_lines`.\n                   • preview: also attach to command preview\n                     (i.e. 'inccommand') events."
    },
    "doc": [
      "Activates buffer-update events on a channel, or as Lua\ncallbacks.",
      "Example (Lua): capture buffer updates in a global `events` variable (use \"print(vim.inspect(events))\" to see its\ncontents): >\n  events = {}\n  vim.api.nvim_buf_attach(0, false, {\n    on_lines=function(...) table.insert(events, {...}) end})\n\n<"
    ],
    "return": [
      "False if attach failed (invalid parameter, or buffer isn't\n    loaded); otherwise True. TODO: LUA_API_NO_EVAL"
    ],
    "seealso": ["|nvim_buf_detach()|", "|api-buffer-updates-lua|"]
  },
  "nvim_buf_call": {
    "annotations": ["|vim.api| only"],
    "signature": "nvim_buf_call({buffer}, {fun}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["LuaRef", "fun"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "fun": "Function to call inside the buffer (currently\n              lua callable only)"
    },
    "doc": [
      "call a function with buffer as temporary current buffer",
      "This temporarily switches current buffer to \"buffer\". If the\ncurrent window already shows \"buffer\", the window is not\nswitched If a window inside the current tabpage (including a\nfloat) already shows the buffer One of these windows will be\nset as current window temporarily. Otherwise a temporary\nscratch window (called the \"autocmd window\" for historical\nreasons) will be used.",
      "This is useful e.g. to call vimL functions that only work with\nthe current buffer/window currently, like |termopen()|."
    ],
    "return": [
      "Return value of function. NB: will deepcopy lua values\n    currently, use upvalues to send lua references in and out."
    ],
    "seealso": []
  },
  "nvim_buf_clear_namespace": {
    "annotations": [],
    "signature": "nvim_buf_clear_namespace({buffer}, {ns_id}, {line_start}, {line_end}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "ns_id"],
      ["Integer", "line_start"],
      ["Integer", "line_end"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "ns_id": "Namespace to clear, or -1 to clear all\n                  namespaces.",
      "line_start": "Start of range of lines to clear",
      "line_end": "End of range of lines to clear (exclusive)\n                  or -1 to clear to end of buffer."
    },
    "doc": [
      "Clears namespaced objects (highlights, extmarks, virtual text)\nfrom a region.",
      "Lines are 0-indexed. |api-indexing| To clear the namespace in\nthe entire buffer, specify line_start=0 and line_end=-1."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_buf_create_user_command": {
    "annotations": [],
    "signature": "nvim_buf_create_user_command({buffer}, {name}, {command}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Object", "command"],
      ["Dict(user_command) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer." },
    "doc": ["Create a new user command |user-commands| in the given buffer."],
    "return": [],
    "seealso": ["nvim_create_user_command"]
  },
  "nvim_buf_del_extmark": {
    "annotations": [],
    "signature": "nvim_buf_del_extmark({buffer}, {ns_id}, {id}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "ns_id"],
      ["Integer", "id"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "ns_id": "Namespace id from |nvim_create_namespace()|",
      "id": "Extmark id"
    },
    "doc": ["Removes an extmark."],
    "return": ["true if the extmark was found, else false"],
    "seealso": []
  },
  "nvim_buf_del_keymap": {
    "annotations": [],
    "signature": "nvim_buf_del_keymap({buffer}, {mode}, {lhs}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "mode"],
      ["String", "lhs"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer" },
    "doc": ["Unmaps a buffer-local |mapping| for the given mode."],
    "return": [],
    "seealso": ["|nvim_del_keymap()|"]
  },
  "nvim_buf_del_mark": {
    "annotations": [],
    "signature": "nvim_buf_del_mark({buffer}, {name}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer to set the mark on", "name": "Mark name" },
    "doc": [
      "Deletes a named mark in the buffer. See |mark-motions|.",
      "\nNote:\n    only deletes marks set in the buffer, if the mark is not\n    set in the buffer it will return false.\n"
    ],
    "return": ["true if the mark was deleted, else false."],
    "seealso": ["|nvim_buf_set_mark()|", "|nvim_del_mark()|"]
  },
  "nvim_buf_del_user_command": {
    "annotations": [],
    "signature": "nvim_buf_del_user_command({buffer}, {name}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer.",
      "name": "Name of the command to delete."
    },
    "doc": [
      "Delete a buffer-local user-defined command.",
      "Only commands created with |:command-buffer| or\n|nvim_buf_create_user_command()| can be deleted with this\nfunction."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_buf_del_var": {
    "annotations": [],
    "signature": "nvim_buf_del_var({buffer}, {name}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "name": "Variable name"
    },
    "doc": ["Removes a buffer-scoped (b:) variable"],
    "return": [],
    "seealso": []
  },
  "nvim_buf_delete": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_buf_delete({buffer}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "opts": "Optional parameters. Keys:\n              • force: Force deletion and ignore unsaved\n                changes.\n              • unload: Unloaded only, do not delete. See\n                |:bunload|"
    },
    "doc": ["Deletes the buffer. See |:bwipeout|"],
    "return": [],
    "seealso": []
  },
  "nvim_buf_detach": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_buf_detach({buffer}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer" },
    "doc": ["Deactivates buffer-update events on the channel."],
    "return": [
      "False if detach failed (because the buffer isn't loaded);\n    otherwise True."
    ],
    "seealso": ["|nvim_buf_attach()|", "|api-lua-detach| for detaching Lua callbacks"]
  },
  "nvim_buf_get_changedtick": {
    "annotations": [],
    "signature": "nvim_buf_get_changedtick({buffer}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer" },
    "doc": ["Gets a changed tick of a buffer"],
    "return": ["`b:changedtick` value."],
    "seealso": []
  },
  "nvim_buf_get_commands": {
    "annotations": [],
    "signature": "nvim_buf_get_commands({buffer}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Dict(get_commands) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "opts": "Optional parameters. Currently not used."
    },
    "doc": ["Gets a map of buffer-local |user-commands|."],
    "return": ["Map of maps describing commands."],
    "seealso": []
  },
  "nvim_buf_get_extmark_by_id": {
    "annotations": [],
    "signature": "nvim_buf_get_extmark_by_id({buffer}, {ns_id}, {id}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "ns_id"],
      ["Integer", "id"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "ns_id": "Namespace id from |nvim_create_namespace()|",
      "id": "Extmark id",
      "opts": "Optional parameters. Keys:\n              • details: Whether to include the details dict"
    },
    "doc": ["Gets the position (0-indexed) of an extmark."],
    "return": ["0-indexed (row, col) tuple or empty list () if extmark id\n    was absent"],
    "seealso": []
  },
  "nvim_buf_get_extmarks": {
    "annotations": [],
    "signature": "nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "ns_id"],
      ["Object", "start"],
      ["Object", "end"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "ns_id": "Namespace id from |nvim_create_namespace()|",
      "start": "Start of range: a 0-indexed (row, col) or valid\n              extmark id (whose position defines the bound).\n              |api-indexing|",
      "end": "End of range (inclusive): a 0-indexed (row, col)\n              or valid extmark id (whose position defines the\n              bound). |api-indexing|",
      "opts": "Optional parameters. Keys:\n              • limit: Maximum number of marks to return\n              • details Whether to include the details dict"
    },
    "doc": [
      "Gets extmarks in \"traversal order\" from a |charwise| region\ndefined by buffer positions (inclusive, 0-indexed\n|api-indexing|).",
      "Region can be given as (row,col) tuples, or valid extmark ids\n(whose positions define the bounds). 0 and -1 are understood\nas (0,0) and (-1,-1) respectively, thus the following are\nequivalent:",
      ">\n  nvim_buf_get_extmarks(0, my_ns, 0, -1, {})\n  nvim_buf_get_extmarks(0, my_ns, [0,0], [-1,-1], {})\n\n<",
      "If `end` is less than `start`, traversal works backwards.\n(Useful with `limit`, to get the first marks prior to a given\nposition.)",
      "Example:",
      ">\n  local a   = vim.api\n  local pos = a.nvim_win_get_cursor(0)\n  local ns  = a.nvim_create_namespace('my-plugin')\n  -- Create new extmark at line 1, column 1.\n  local m1  = a.nvim_buf_set_extmark(0, ns, 0, 0, {})\n  -- Create new extmark at line 3, column 1.\n  local m2  = a.nvim_buf_set_extmark(0, ns, 0, 2, {})\n  -- Get extmarks only from line 3.\n  local ms  = a.nvim_buf_get_extmarks(0, ns, {2,0}, {2,0}, {})\n  -- Get all marks in this buffer + namespace.\n  local all = a.nvim_buf_get_extmarks(0, ns, 0, -1, {})\n  print(vim.inspect(ms))\n\n<"
    ],
    "return": ["List of [extmark_id, row, col] tuples in \"traversal\n    order\"."],
    "seealso": []
  },
  "nvim_buf_get_keymap": {
    "annotations": [],
    "signature": "nvim_buf_get_keymap({buffer}, {mode}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "mode"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "mode": "Mode short-name (\"n\", \"i\", \"v\", ...)",
      "buffer": "Buffer handle, or 0 for current buffer"
    },
    "doc": ["Gets a list of buffer-local |mapping| definitions."],
    "return": [
      "Array of maparg()-like dictionaries describing mappings.\n    The \"buffer\" key holds the associated buffer handle."
    ],
    "seealso": []
  },
  "nvim_buf_get_lines": {
    "annotations": [],
    "signature": "nvim_buf_get_lines({buffer}, {start}, {end}, {strict_indexing}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "start"],
      ["Integer", "end"],
      ["Boolean", "strict_indexing"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "start": "First line index",
      "end": "Last line index, exclusive",
      "strict_indexing": "Whether out-of-bounds should be an\n                       error."
    },
    "doc": [
      "Gets a line-range from the buffer.",
      "Indexing is zero-based, end-exclusive. Negative indices are\ninterpreted as length+1+index: -1 refers to the index past the\nend. So to get the last element use start=-2 and end=-1.",
      "Out-of-bounds indices are clamped to the nearest valid value,\nunless `strict_indexing` is set."
    ],
    "return": ["Array of lines, or empty array for unloaded buffer."],
    "seealso": []
  },
  "nvim_buf_get_mark": {
    "annotations": [],
    "signature": "nvim_buf_get_mark({buffer}, {name}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "name": "Mark name"
    },
    "doc": [
      "Returns a tuple (row,col) representing the position of the\nnamed mark. See |mark-motions|.",
      "Marks are (1,0)-indexed. |api-indexing|"
    ],
    "return": [
      "(row, col) tuple, (0, 0) if the mark is not set, or is an\n    uppercase/file mark set in another buffer."
    ],
    "seealso": ["|nvim_buf_set_mark()|", "|nvim_buf_del_mark()|"]
  },
  "nvim_buf_get_name": {
    "annotations": [],
    "signature": "nvim_buf_get_name({buffer}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer" },
    "doc": ["Gets the full file name for the buffer"],
    "return": ["Buffer name"],
    "seealso": []
  },
  "nvim_buf_get_offset": {
    "annotations": [],
    "signature": "nvim_buf_get_offset({buffer}, {index}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "index"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "index": "Line index"
    },
    "doc": [
      "Returns the byte offset of a line (0-indexed). |api-indexing|",
      "Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is\none byte. 'fileformat' and 'fileencoding' are ignored. The\nline index just after the last line gives the total byte-count\nof the buffer. A final EOL byte is counted if it would be\nwritten, see 'eol'.",
      "Unlike |line2byte()|, throws error for out-of-bounds indexing.\nReturns -1 for unloaded buffer."
    ],
    "return": ["Integer byte offset, or -1 for unloaded buffer."],
    "seealso": []
  },
  "nvim_buf_get_option": {
    "annotations": [],
    "signature": "nvim_buf_get_option({buffer}, {name}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "name": "Option name"
    },
    "doc": ["Gets a buffer option value"],
    "return": ["Option value"],
    "seealso": []
  },
  "nvim_buf_get_text": {
    "annotations": [],
    "signature": "nvim_buf_get_text({buffer}, {start_row}, {start_col}, {end_row}, {end_col}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "start_row"],
      ["Integer", "start_col"],
      ["Integer", "end_row"],
      ["Integer", "end_col"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "start_row": "First line index",
      "start_col": "Starting column (byte offset) on first line",
      "end_row": "Last line index, inclusive",
      "end_col": "Ending column (byte offset) on last line,\n                 exclusive",
      "opts": "Optional parameters. Currently unused."
    },
    "doc": [
      "Gets a range from the buffer.",
      "This differs from |nvim_buf_get_lines()| in that it allows\nretrieving only portions of a line.",
      "Indexing is zero-based. Row indices are end-inclusive, and\ncolumn indices are end-exclusive.",
      "Prefer |nvim_buf_get_lines()| when retrieving entire lines."
    ],
    "return": ["Array of lines, or empty array for unloaded buffer."],
    "seealso": []
  },
  "nvim_buf_get_var": {
    "annotations": [],
    "signature": "nvim_buf_get_var({buffer}, {name}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "name": "Variable name"
    },
    "doc": ["Gets a buffer-scoped (b:) variable."],
    "return": ["Variable value"],
    "seealso": []
  },
  "nvim_buf_is_loaded": {
    "annotations": [],
    "signature": "nvim_buf_is_loaded({buffer})",
    "parameters": [["Buffer", "buffer"]],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer" },
    "doc": [
      "Checks if a buffer is valid and loaded. See |api-buffer| for\nmore info about unloaded buffers."
    ],
    "return": ["true if the buffer is valid and loaded, false otherwise."],
    "seealso": []
  },
  "nvim_buf_is_valid": {
    "annotations": [],
    "signature": "nvim_buf_is_valid({buffer})",
    "parameters": [["Buffer", "buffer"]],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer" },
    "doc": [
      "Checks if a buffer is valid.",
      "\nNote:\n    Even if a buffer is valid it may have been unloaded. See\n    |api-buffer| for more info about unloaded buffers.\n"
    ],
    "return": ["true if the buffer is valid, false otherwise."],
    "seealso": []
  },
  "nvim_buf_line_count": {
    "annotations": [],
    "signature": "nvim_buf_line_count({buffer}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer" },
    "doc": ["Returns the number of lines in the given buffer."],
    "return": ["Line count, or 0 for unloaded buffer. |api-buffer|"],
    "seealso": []
  },
  "nvim_buf_set_extmark": {
    "annotations": [],
    "signature": "nvim_buf_set_extmark({buffer}, {ns_id}, {line}, {col}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "ns_id"],
      ["Integer", "line"],
      ["Integer", "col"],
      ["Dict(set_extmark) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "ns_id": "Namespace id from |nvim_create_namespace()|",
      "line": "Line where to place the mark, 0-based.\n              |api-indexing|",
      "col": "Column where to place the mark, 0-based.\n              |api-indexing|",
      "opts": "Optional parameters.\n              • id : id of the extmark to edit.\n              • end_row : ending line of the mark, 0-based\n                inclusive.\n              • end_col : ending col of the mark, 0-based\n                exclusive.\n              • hl_group : name of the highlight group used to\n                highlight this mark.\n              • hl_eol : when true, for a multiline highlight\n                covering the EOL of a line, continue the\n                highlight for the rest of the screen line\n                (just like for diff and cursorline highlight).\n              • virt_text : virtual text to link to this mark.\n                A list of [text, highlight] tuples, each\n                representing a text chunk with specified\n                highlight. `highlight` element can either be a\n                a single highlight group, or an array of\n                multiple highlight groups that will be stacked\n                (highest priority last). A highlight group can\n                be supplied either as a string or as an\n                integer, the latter which can be obtained\n                using |nvim_get_hl_id_by_name|.\n              • virt_text_pos : position of virtual text.\n                Possible values:\n                • \"eol\": right after eol character (default)\n                • \"overlay\": display over the specified\n                  column, without shifting the underlying\n                  text.\n                • \"right_align\": display right aligned in the\n                  window.\n\n              • virt_text_win_col : position the virtual text\n                at a fixed window column (starting from the\n                first text column)\n              • virt_text_hide : hide the virtual text when\n                the background text is selected or hidden due\n                to horizontal scroll 'nowrap'\n              • hl_mode : control how highlights are combined\n                with the highlights of the text. Currently\n                only affects virt_text highlights, but might\n                affect `hl_group` in later versions.\n                • \"replace\": only show the virt_text color.\n                  This is the default\n                • \"combine\": combine with background text\n                  color\n                • \"blend\": blend with background text color.\n\n              • virt_lines : virtual lines to add next to this\n                mark This should be an array over lines, where\n                each line in turn is an array over [text,\n                highlight] tuples. In general, buffer and\n                window options do not affect the display of\n                the text. In particular 'wrap' and 'linebreak'\n                options do not take effect, so the number of\n                extra screen lines will always match the size\n                of the array. However the 'tabstop' buffer\n                option is still used for hard tabs. By default\n                lines are placed below the buffer line\n                containing the mark.\n              • virt_lines_above: place virtual lines above\n                instead.\n              • virt_lines_leftcol: Place extmarks in the\n                leftmost column of the window, bypassing sign\n                and number columns.\n              • ephemeral : for use with\n                |nvim_set_decoration_provider| callbacks. The\n                mark will only be used for the current redraw\n                cycle, and not be permantently stored in the\n                buffer.\n              • right_gravity : boolean that indicates the\n                direction the extmark will be shifted in when\n                new text is inserted (true for right, false\n                for left). defaults to true.\n              • end_right_gravity : boolean that indicates the\n                direction the extmark end position (if it\n                exists) will be shifted in when new text is\n                inserted (true for right, false for left).\n                Defaults to false.\n              • priority: a priority value for the highlight\n                group. For example treesitter highlighting\n                uses a value of 100.\n              • strict: boolean that indicates extmark should\n                not be placed if the line or column value is\n                past the end of the buffer or end of the line\n                respectively. Defaults to true.\n              • sign_text: string of length 1-2 used to\n                display in the sign column. Note: ranges are\n                unsupported and decorations are only applied\n                to start_row\n              • sign_hl_group: name of the highlight group\n                used to highlight the sign column text. Note:\n                ranges are unsupported and decorations are\n                only applied to start_row\n              • number_hl_group: name of the highlight group\n                used to highlight the number column. Note:\n                ranges are unsupported and decorations are\n                only applied to start_row\n              • line_hl_group: name of the highlight group\n                used to highlight the whole line. Note: ranges\n                are unsupported and decorations are only\n                applied to start_row\n              • cursorline_hl_group: name of the highlight\n                group used to highlight the line when the\n                cursor is on the same line as the mark and\n                'cursorline' is enabled. Note: ranges are\n                unsupported and decorations are only applied\n                to start_row\n              • conceal: string which should be either empty\n                or a single character. Enable concealing\n                similar to |:syn-conceal|. When a character is\n                supplied it is used as |:syn-cchar|.\n                \"hl_group\" is used as highlight for the cchar\n                if provided, otherwise it defaults to\n                |hl-Conceal|.\n              • ui_watched: boolean that indicates the mark\n                should be drawn by a UI. When set, the UI will\n                receive win_extmark events. Note: the mark is\n                positioned by virt_text attributes. Can be\n                used together with virt_text."
    },
    "doc": [
      "Creates or updates an extmark.",
      "By default a new extmark is created when no id is passed in,\nbut it is also possible to create a new mark by passing in a\npreviously unused id or move an existing mark by passing in\nits id. The caller must then keep track of existing and unused\nids itself. (Useful over RPC, to avoid waiting for the return\nvalue.)",
      "Using the optional arguments, it is possible to use this to\nhighlight a range of text, and also to associate virtual text\nto the mark."
    ],
    "return": ["Id of the created/updated extmark"],
    "seealso": []
  },
  "nvim_buf_set_keymap": {
    "annotations": [],
    "signature": "nvim_buf_set_keymap({buffer}, {mode}, {lhs}, {rhs}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "mode"],
      ["String", "lhs"],
      ["String", "rhs"],
      ["Dict(keymap) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer handle, or 0 for current buffer" },
    "doc": ["Sets a buffer-local |mapping| for the given mode."],
    "return": [],
    "seealso": ["|nvim_set_keymap()|"]
  },
  "nvim_buf_set_lines": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_buf_set_lines({buffer}, {start}, {end}, {strict_indexing}, {replacement}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "start"],
      ["Integer", "end"],
      ["Boolean", "strict_indexing"],
      ["ArrayOf(String)", "replacement"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "start": "First line index",
      "end": "Last line index, exclusive",
      "strict_indexing": "Whether out-of-bounds should be an\n                       error.",
      "replacement": "Array of lines to use as replacement"
    },
    "doc": [
      "Sets (replaces) a line-range in the buffer.",
      "Indexing is zero-based, end-exclusive. Negative indices are\ninterpreted as length+1+index: -1 refers to the index past the\nend. So to change or delete the last element use start=-2 and\nend=-1.",
      "To insert lines at a given index, set `start` and `end` to the\nsame index. To delete a range of lines, set `replacement` to\nan empty array.",
      "Out-of-bounds indices are clamped to the nearest valid value,\nunless `strict_indexing` is set."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_buf_set_mark": {
    "annotations": [],
    "signature": "nvim_buf_set_mark({buffer}, {name}, {line}, {col}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Integer", "line"],
      ["Integer", "col"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer to set the mark on",
      "name": "Mark name",
      "line": "Line number",
      "col": "Column/row number",
      "opts": "Optional parameters. Reserved for future use."
    },
    "doc": [
      "Sets a named mark in the given buffer, all marks are allowed\nfile/uppercase, visual, last change, etc. See |mark-motions|.",
      "Marks are (1,0)-indexed. |api-indexing|",
      "\nNote:\n    Passing 0 as line deletes the mark\n"
    ],
    "return": ["true if the mark was set, else false."],
    "seealso": ["|nvim_buf_del_mark()|", "|nvim_buf_get_mark()|"]
  },
  "nvim_buf_set_name": {
    "annotations": [],
    "signature": "nvim_buf_set_name({buffer}, {name}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "name": "Buffer name"
    },
    "doc": ["Sets the full file name for a buffer"],
    "return": [],
    "seealso": []
  },
  "nvim_buf_set_option": {
    "annotations": [],
    "signature": "nvim_buf_set_option({buffer}, {name}, {value}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "name": "Option name",
      "value": "Option value"
    },
    "doc": [
      "Sets a buffer option value. Passing 'nil' as value deletes the\noption (only works if there's a global fallback)"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_buf_set_text": {
    "annotations": [],
    "signature": "nvim_buf_set_text({buffer}, {start_row}, {start_col}, {end_row}, {end_col}, {replacement}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Integer", "start_row"],
      ["Integer", "start_col"],
      ["Integer", "end_row"],
      ["Integer", "end_col"],
      ["ArrayOf(String)", "replacement"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "start_row": "First line index",
      "start_col": "Starting column (byte offset) on first line",
      "end_row": "Last line index, inclusive",
      "end_col": "Ending column (byte offset) on last line,\n                   exclusive",
      "replacement": "Array of lines to use as replacement"
    },
    "doc": [
      "Sets (replaces) a range in the buffer",
      "This is recommended over |nvim_buf_set_lines()| when only\nmodifying parts of a line, as extmarks will be preserved on\nnon-modified parts of the touched lines.",
      "Indexing is zero-based. Row indices are end-inclusive, and\ncolumn indices are end-exclusive.",
      "To insert text at a given `(row, column)` location, use\n`start_row = end_row = row` and `start_col = end_col = col`.\nTo delete the text in a range, use `replacement = {}`.",
      "Prefer |nvim_buf_set_lines()| if you are only adding or\ndeleting entire lines."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_buf_set_var": {
    "annotations": [],
    "signature": "nvim_buf_set_var({buffer}, {name}, {value}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer handle, or 0 for current buffer",
      "name": "Variable name",
      "value": "Variable value"
    },
    "doc": ["Sets a buffer-scoped (b:) variable"],
    "return": [],
    "seealso": []
  },
  "nvim_call_atomic": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_call_atomic({calls}, {err})",
    "parameters": [
      ["Array", "calls"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "calls": "an array of calls, where each call is described\n             by an array with two elements: the request name,\n             and an array of arguments."
    },
    "doc": [
      "Calls many API methods atomically.",
      "This has two main usages:\n1. To perform several requests from an async context\n   atomically, i.e. without interleaving redraws, RPC requests\n   from other clients, or user interactions (however API\n   methods may trigger autocommands or event processing which\n   have such side effects, e.g. |:sleep| may wake timers).\n2. To minimize RPC overhead (roundtrips) of a sequence of many\n   requests.\n"
    ],
    "return": [
      "Array of two elements. The first is an array of return\n    values. The second is NIL if all calls succeeded. If a\n    call resulted in an error, it is a three-element array\n    with the zero-based index of the call which resulted in an\n    error, the error type and the error message. If an error\n    occurred, the values from all preceding calls will still\n    be returned."
    ],
    "seealso": []
  },
  "nvim_call_dict_function": {
    "annotations": [],
    "signature": "nvim_call_dict_function({dict}, {fn}, {args}, {err})",
    "parameters": [
      ["Object", "dict"],
      ["String", "fn"],
      ["Array", "args"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "dict": "Dictionary, or String evaluating to a VimL |self|\n            dict",
      "fn": "Name of the function defined on the VimL dict",
      "args": "Function arguments packed in an Array"
    },
    "doc": [
      "Calls a VimL |Dictionary-function| with the given arguments.",
      "On execution error: fails with VimL error, updates v:errmsg."
    ],
    "return": ["Result of the function call"],
    "seealso": []
  },
  "nvim_call_function": {
    "annotations": [],
    "signature": "nvim_call_function({fn}, {args}, {err})",
    "parameters": [
      ["String", "fn"],
      ["Array", "args"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "fn": "Function to call",
      "args": "Function arguments packed in an Array"
    },
    "doc": [
      "Calls a VimL function with the given arguments.",
      "On execution error: fails with VimL error, updates v:errmsg."
    ],
    "return": ["Result of the function call"],
    "seealso": []
  },
  "nvim_chan_send": {
    "annotations": ["|RPC| only", "|vim.api| only"],
    "signature": "nvim_chan_send({chan}, {data}, {err})",
    "parameters": [
      ["Integer", "chan"],
      ["String", "data"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "chan": "id of the channel",
      "data": "data to write. 8-bit clean: can contain NUL bytes."
    },
    "doc": [
      "Send data to channel `id`. For a job, it writes it to the\nstdin of the process. For the stdio channel |channel-stdio|,\nit writes to Nvim's stdout. For an internal terminal instance\n(|nvim_open_term()|) it writes directly to terminal output.\nSee |channel-bytes| for more information.",
      "This function writes raw data, not RPC messages. If the\nchannel was created with `rpc=true` then the channel expects\nRPC messages, use |vim.rpcnotify()| and |vim.rpcrequest()|\ninstead."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_clear_autocmds": {
    "annotations": [],
    "signature": "nvim_clear_autocmds({opts}, {err})",
    "parameters": [
      ["Dict(clear_autocmds) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "opts": "Parameters\n            • event: (string|table) Examples:\n              • event: \"pat1\"\n              • event: { \"pat1\" }\n              • event: { \"pat1\", \"pat2\", \"pat3\" }\n\n            • pattern: (string|table)\n              • pattern or patterns to match exactly.\n                • For example, if you have `*.py` as that\n                  pattern for the autocmd, you must pass\n                  `*.py` exactly to clear it. `test.py` will\n                  not match the pattern.\n\n              • defaults to clearing all patterns.\n              • NOTE: Cannot be used with {buffer}\n\n            • buffer: (bufnr)\n              • clear only |autocmd-buflocal| autocommands.\n              • NOTE: Cannot be used with {pattern}\n\n            • group: (string|int) The augroup name or id.\n              • NOTE: If not passed, will only delete autocmds not in any group."
    },
    "doc": [
      "Clear all autocommands that match the corresponding {opts}. To\ndelete a particular autocmd, see |nvim_del_autocmd|."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_cmd": {
    "annotations": [],
    "signature": "nvim_cmd({cmd}, {opts}, {err})",
    "parameters": [
      ["Dict(cmd) *", "cmd"],
      ["Dict(cmd_opts) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "cmd": "Command to execute. Must be a Dictionary that can\n            contain the same values as the return value of\n            |nvim_parse_cmd()| except \"addr\", \"nargs\" and\n            \"nextcmd\" which are ignored if provided. All\n            values except for \"cmd\" are optional.",
      "opts": "Optional parameters.\n            • output: (boolean, default false) Whether to\n              return command output."
    },
    "doc": [
      "Executes an Ex command.",
      "Unlike |nvim_command()| this command takes a structured\nDictionary instead of a String. This allows for easier\nconstruction and manipulation of an Ex command. This also\nallows for things such as having spaces inside a command\nargument, expanding filenames in a command that otherwise\ndoesn't expand filenames, etc.",
      "On execution error: fails with VimL error, updates v:errmsg."
    ],
    "return": [
      "Command output (non-error, non-shell |:!|) if `output` is\n    true, else empty string."
    ],
    "seealso": ["|nvim_exec()|", "|nvim_command()|"]
  },
  "nvim_command": {
    "annotations": [],
    "signature": "nvim_command({command}, {err})",
    "parameters": [
      ["String", "command"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "command": "Ex command string" },
    "doc": [
      "Executes an Ex command.",
      "On execution error: fails with VimL error, updates v:errmsg.",
      "Prefer using |nvim_cmd()| or |nvim_exec()| over this. To\nevaluate multiple lines of Vim script or an Ex command\ndirectly, use |nvim_exec()|. To construct an Ex command using\na structured format and then execute it, use |nvim_cmd()|. To\nmodify an Ex command before evaluating it, use\n|nvim_parse_cmd()| in conjunction with |nvim_cmd()|."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_create_augroup": {
    "annotations": [],
    "signature": "nvim_create_augroup({name}, {opts}, {err})",
    "parameters": [
      ["String", "name"],
      ["Dict(create_augroup) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "name": "String: The name of the group",
      "opts": "Dictionary Parameters\n            • clear (bool) optional: defaults to true. Clear\n              existing commands if the group already exists\n              |autocmd-groups|."
    },
    "doc": [
      "Create or get an autocommand group |autocmd-groups|.",
      "To get an existing group id, do: >\n    local id = vim.api.nvim_create_augroup(\"MyGroup\", {\n        clear = false\n    })\n\n<"
    ],
    "return": ["Integer id of the created group."],
    "seealso": ["|autocmd-groups|"]
  },
  "nvim_create_autocmd": {
    "annotations": [],
    "signature": "nvim_create_autocmd({event}, {opts}, {err})",
    "parameters": [
      ["Object", "event"],
      ["Dict(create_autocmd) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "event": "(string|array) The event or events to register\n             this autocommand",
      "opts": "Dictionary of autocommand options:\n             • group (string|integer) optional: the\n               autocommand group name or id to match against.\n             • pattern (string|array) optional: pattern or\n               patterns to match against |autocmd-pattern|.\n             • buffer (integer) optional: buffer number for\n               buffer local autocommands |autocmd-buflocal|.\n               Cannot be used with {pattern}.\n             • desc (string) optional: description of the\n               autocommand.\n             • callback (function|string) optional: if a\n               string, the name of a Vimscript function to\n               call when this autocommand is triggered.\n               Otherwise, a Lua function which is called when\n               this autocommand is triggered. Cannot be used\n               with {command}. Lua callbacks can return true\n               to delete the autocommand; in addition, they\n               accept a single table argument with the\n               following keys:\n               • id: (number) the autocommand id\n               • event: (string) the name of the event that\n                 triggered the autocommand |autocmd-events|\n               • group: (number|nil) the autocommand group id,\n                 if it exists\n               • match: (string) the expanded value of\n                 |<amatch>|\n               • buf: (number) the expanded value of |<abuf>|\n               • file: (string) the expanded value of\n                 |<afile>|\n               • data: (any) arbitrary data passed to\n                 |nvim_exec_autocmds()|\n\n             • command (string) optional: Vim command to\n               execute on event. Cannot be used with\n               {callback}\n             • once (boolean) optional: defaults to false. Run\n               the autocommand only once |autocmd-once|.\n             • nested (boolean) optional: defaults to false.\n               Run nested autocommands |autocmd-nested|."
    },
    "doc": [
      "Create an |autocommand|",
      "The API allows for two (mutually exclusive) types of actions\nto be executed when the autocommand triggers: a callback\nfunction (Lua or Vimscript), or a command (like regular\nautocommands).",
      "Example using callback: >\n    -- Lua function\n    local myluafun = function() print(\"This buffer enters\") end\n\n    -- Vimscript function name (as a string)\n    local myvimfun = \"g:MyVimFunction\"\n\n    vim.api.nvim_create_autocmd({\"BufEnter\", \"BufWinEnter\"}, {\n      pattern = {\"*.c\", \"*.h\"},\n      callback = myluafun,  -- Or myvimfun\n    })\n\n<",
      "Lua functions receive a table with information about the\nautocmd event as an argument. To use a function which itself\naccepts another (optional) parameter, wrap the function in a\nlambda:",
      ">\n    -- Lua function with an optional parameter.\n    -- The autocmd callback would pass a table as argument but this\n    -- function expects number|nil\n    local myluafun = function(bufnr) bufnr = bufnr or vim.api.nvim_get_current_buf() end\n\n    vim.api.nvim_create_autocmd({\"BufEnter\", \"BufWinEnter\"}, {\n      pattern = {\"*.c\", \"*.h\"},\n      callback = function() myluafun() end,\n    })\n\n<",
      "Example using command: >\n    vim.api.nvim_create_autocmd({\"BufEnter\", \"BufWinEnter\"}, {\n      pattern = {\"*.c\", \"*.h\"},\n      command = \"echo 'Entering a C or C++ file'\",\n    })\n\n<",
      "Example values for pattern: >\n  pattern = \"*.py\"\n  pattern = { \"*.py\", \"*.pyi\" }\n\n<",
      "Example values for event: >\n  \"BufWritePre\"\n  {\"CursorHold\", \"BufWritePre\", \"BufWritePost\"}\n\n<"
    ],
    "return": ["Integer id of the created autocommand."],
    "seealso": ["|autocommand|", "|nvim_del_autocmd()|"]
  },
  "nvim_create_buf": {
    "annotations": [],
    "signature": "nvim_create_buf({listed}, {scratch}, {err})",
    "parameters": [
      ["Boolean", "listed"],
      ["Boolean", "scratch"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "listed": "Sets 'buflisted'",
      "scratch": "Creates a \"throwaway\" |scratch-buffer| for\n               temporary work (always 'nomodified'). Also sets\n               'nomodeline' on the buffer."
    },
    "doc": ["Creates a new, empty, unnamed buffer."],
    "return": ["Buffer handle, or 0 on error"],
    "seealso": ["buf_open_scratch"]
  },
  "nvim_create_namespace": {
    "annotations": [],
    "signature": "nvim_create_namespace({name})",
    "parameters": [["String", "name"]],
    "parameters_doc": { "name": "Namespace name or empty string" },
    "doc": [
      "Creates a new *namespace* or gets an existing one.",
      "Namespaces are used for buffer highlights and virtual text,\nsee |nvim_buf_add_highlight()| and |nvim_buf_set_extmark()|.",
      "Namespaces can be named or anonymous. If `name` matches an\nexisting namespace, the associated id is returned. If `name`\nis an empty string a new, anonymous namespace is created."
    ],
    "return": ["Namespace id"],
    "seealso": []
  },
  "nvim_create_user_command": {
    "annotations": [],
    "signature": "nvim_create_user_command({name}, {command}, {opts}, {err})",
    "parameters": [
      ["String", "name"],
      ["Object", "command"],
      ["Dict(user_command) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "name": "Name of the new user command. Must begin with\n               an uppercase letter.",
      "command": "Replacement command to execute when this user\n               command is executed. When called from Lua, the\n               command can also be a Lua function. The\n               function is called with a single table argument\n               that contains the following keys:\n               • args: (string) The args passed to the\n                 command, if any |<args>|\n               • fargs: (table) The args split by unescaped\n                 whitespace (when more than one argument is\n                 allowed), if any |<f-args>|\n               • bang: (boolean) \"true\" if the command was\n                 executed with a ! modifier |<bang>|\n               • line1: (number) The starting line of the\n                 command range |<line1>|\n               • line2: (number) The final line of the command\n                 range |<line2>|\n               • range: (number) The number of items in the\n                 command range: 0, 1, or 2 |<range>|\n               • count: (number) Any count supplied |<count>|\n               • reg: (string) The optional register, if\n                 specified |<reg>|\n               • mods: (string) Command modifiers, if any\n                 |<mods>|\n               • smods: (table) Command modifiers in a\n                 structured format. Has the same structure as\n                 the \"mods\" key of |nvim_parse_cmd()|.",
      "opts": "Optional command attributes. See\n               |command-attributes| for more details. To use\n               boolean attributes (such as |:command-bang| or\n               |:command-bar|) set the value to \"true\". In\n               addition to the string options listed in\n               |:command-complete|, the \"complete\" key also\n               accepts a Lua function which works like the\n               \"customlist\" completion mode\n               |:command-completion-customlist|. Additional\n               parameters:\n               • desc: (string) Used for listing the command\n                 when a Lua function is used for {command}.\n               • force: (boolean, default true) Override any\n                 previous definition.\n               • preview: (function) Preview callback for\n                 'inccommand' |:command-preview|"
    },
    "doc": [
      "Create a new user command |user-commands|",
      "{name} is the name of the new command. The name must begin\nwith an uppercase letter.",
      "{command} is the replacement text or Lua function to execute.",
      "Example: >\n   :call nvim_create_user_command('SayHello', 'echo \"Hello world!\"', {})\n   :SayHello\n   Hello world!\n\n<"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_del_augroup_by_id": {
    "annotations": [],
    "signature": "nvim_del_augroup_by_id({id}, {err})",
    "parameters": [
      ["Integer", "id"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "id": "Integer The id of the group." },
    "doc": [
      "Delete an autocommand group by id.",
      "To get a group id one can use |nvim_get_autocmds()|.",
      "NOTE: behavior differs from |augroup-delete|. When deleting a\ngroup, autocommands contained in this group will also be\ndeleted and cleared. This group will no longer exist."
    ],
    "return": [],
    "seealso": ["|nvim_del_augroup_by_name()|", "|nvim_create_augroup()|"]
  },
  "nvim_del_augroup_by_name": {
    "annotations": [],
    "signature": "nvim_del_augroup_by_name({name}, {err})",
    "parameters": [
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "String The name of the group." },
    "doc": [
      "Delete an autocommand group by name.",
      "NOTE: behavior differs from |augroup-delete|. When deleting a\ngroup, autocommands contained in this group will also be\ndeleted and cleared. This group will no longer exist."
    ],
    "return": [],
    "seealso": ["|autocommand-groups|"]
  },
  "nvim_del_autocmd": {
    "annotations": [],
    "signature": "nvim_del_autocmd({id}, {err})",
    "parameters": [
      ["Integer", "id"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "id": "Integer The id returned by nvim_create_autocmd" },
    "doc": [
      "Delete an autocommand by id.",
      "NOTE: Only autocommands created via the API have an id."
    ],
    "return": [],
    "seealso": ["|nvim_create_autocmd()|"]
  },
  "nvim_del_current_line": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_del_current_line({err})",
    "parameters": [["Error *", "err"]],
    "parameters_doc": {},
    "doc": ["Deletes the current line."],
    "return": [],
    "seealso": []
  },
  "nvim_del_keymap": {
    "annotations": [],
    "signature": "nvim_del_keymap({mode}, {lhs}, {err})",
    "parameters": [
      ["String", "mode"],
      ["String", "lhs"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": [
      "Unmaps a global |mapping| for the given mode.",
      "To unmap a buffer-local mapping, use |nvim_buf_del_keymap()|."
    ],
    "return": [],
    "seealso": ["|nvim_set_keymap()|"]
  },
  "nvim_del_mark": {
    "annotations": [],
    "signature": "nvim_del_mark({name}, {err})",
    "parameters": [
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Mark name" },
    "doc": [
      "Deletes an uppercase/file named mark. See |mark-motions|.",
      "\nNote:\n    fails with error if a lowercase or buffer local named mark\n    is used.\n"
    ],
    "return": ["true if the mark was deleted, else false."],
    "seealso": ["|nvim_buf_del_mark()|", "|nvim_get_mark()|"]
  },
  "nvim_del_user_command": {
    "annotations": [],
    "signature": "nvim_del_user_command({name}, {err})",
    "parameters": [
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Name of the command to delete." },
    "doc": ["Delete a user-defined command."],
    "return": [],
    "seealso": []
  },
  "nvim_del_var": {
    "annotations": [],
    "signature": "nvim_del_var({name}, {err})",
    "parameters": [
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Variable name" },
    "doc": ["Removes a global (g:) variable."],
    "return": [],
    "seealso": []
  },
  "nvim_echo": {
    "annotations": [],
    "signature": "nvim_echo({chunks}, {history}, {opts}, {err})",
    "parameters": [
      ["Array", "chunks"],
      ["Boolean", "history"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "chunks": "A list of [text, hl_group] arrays, each\n               representing a text chunk with specified\n               highlight. `hl_group` element can be omitted\n               for no highlight.",
      "history": "if true, add to |message-history|.",
      "opts": "Optional parameters. Reserved for future use."
    },
    "doc": ["Echo a message."],
    "return": [],
    "seealso": []
  },
  "nvim_err_write": {
    "annotations": [],
    "signature": "nvim_err_write({str})",
    "parameters": [["String", "str"]],
    "parameters_doc": { "str": "Message" },
    "doc": [
      "Writes a message to the Vim error buffer. Does not append\n\"\\n\", the message is buffered (won't display) until a linefeed\nis written."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_err_writeln": {
    "annotations": [],
    "signature": "nvim_err_writeln({str})",
    "parameters": [["String", "str"]],
    "parameters_doc": { "str": "Message" },
    "doc": [
      "Writes a message to the Vim error buffer. Appends \"\\n\", so the\nbuffer is flushed (and displayed)."
    ],
    "return": [],
    "seealso": ["nvim_err_write()"]
  },
  "nvim_eval": {
    "annotations": [],
    "signature": "nvim_eval({expr}, {err})",
    "parameters": [
      ["String", "expr"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "expr": "VimL expression string" },
    "doc": [
      "Evaluates a VimL |expression|. Dictionaries and Lists are\nrecursively expanded.",
      "On execution error: fails with VimL error, updates v:errmsg."
    ],
    "return": ["Evaluation result or expanded object"],
    "seealso": []
  },
  "nvim_eval_statusline": {
    "annotations": ["|api-fast|"],
    "signature": "nvim_eval_statusline({str}, {opts}, {err})",
    "parameters": [
      ["String", "str"],
      ["Dict(eval_statusline) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "str": "Statusline string (see 'statusline').",
      "opts": "Optional parameters.\n            • winid: (number) |window-ID| of the window to use\n              as context for statusline.\n            • maxwidth: (number) Maximum width of statusline.\n            • fillchar: (string) Character to fill blank\n              spaces in the statusline (see 'fillchars').\n              Treated as single-width even if it isn't.\n            • highlights: (boolean) Return highlight\n              information.\n            • use_winbar: (boolean) Evaluate winbar instead of\n              statusline.\n            • use_tabline: (boolean) Evaluate tabline instead\n              of statusline. When |TRUE|, {winid} is ignored.\n              Mutually exclusive with {use_winbar}."
    },
    "doc": ["Evaluates statusline string."],
    "return": [
      "Dictionary containing statusline information, with these\n    keys:\n    • str: (string) Characters that will be displayed on the\n      statusline.\n    • width: (number) Display width of the statusline.\n    • highlights: Array containing highlight information of\n      the statusline. Only included when the \"highlights\" key\n      in {opts} is |TRUE|. Each element of the array is a\n      |Dictionary| with these keys:\n      • start: (number) Byte index (0-based) of first\n        character that uses the highlight.\n      • group: (string) Name of highlight group.\n\n"
    ],
    "seealso": []
  },
  "nvim_exec": {
    "annotations": [],
    "signature": "nvim_exec({src}, {output}, {err})",
    "parameters": [
      ["String", "src"],
      ["Boolean", "output"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "src": "Vimscript code",
      "output": "Capture and return all (non-error, non-shell\n              |:!|) output"
    },
    "doc": [
      "Executes Vimscript (multiline block of Ex commands), like\nanonymous |:source|.",
      "Unlike |nvim_command()| this function supports heredocs,\nscript-scope (s:), etc.",
      "On execution error: fails with VimL error, updates v:errmsg."
    ],
    "return": [
      "Output (non-error, non-shell |:!|) if `output` is true,\n    else empty string."
    ],
    "seealso": ["|execute()|", "|nvim_command()|", "|nvim_cmd()|"]
  },
  "nvim_exec_autocmds": {
    "annotations": [],
    "signature": "nvim_exec_autocmds({event}, {opts}, {err})",
    "parameters": [
      ["Object", "event"],
      ["Dict(exec_autocmds) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "event": "(String|Array) The event or events to execute",
      "opts": "Dictionary of autocommand options:\n             • group (string|integer) optional: the\n               autocommand group name or id to match against.\n               |autocmd-groups|.\n             • pattern (string|array) optional: defaults to\n               \"*\" |autocmd-pattern|. Cannot be used with\n               {buffer}.\n             • buffer (integer) optional: buffer number\n               |autocmd-buflocal|. Cannot be used with\n               {pattern}.\n             • modeline (bool) optional: defaults to true.\n               Process the modeline after the autocommands\n               |<nomodeline>|.\n             • data (any): arbitrary data to send to the\n               autocommand callback. See\n               |nvim_create_autocmd()| for details."
    },
    "doc": [
      "Execute all autocommands for {event} that match the\ncorresponding {opts} |autocmd-execute|."
    ],
    "return": [],
    "seealso": ["|:doautocmd|"]
  },
  "nvim_exec_lua": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_exec_lua({code}, {args}, {err})",
    "parameters": [
      ["String", "code"],
      ["Array", "args"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "code": "Lua code to execute", "args": "Arguments to the code" },
    "doc": [
      "Execute Lua code. Parameters (if any) are available as `...`\ninside the chunk. The chunk can return a value.",
      "Only statements are executed. To evaluate an expression,\nprefix it with `return`: return my_function(...)"
    ],
    "return": ["Return value of Lua code if present or NIL."],
    "seealso": []
  },
  "nvim_feedkeys": {
    "annotations": [],
    "signature": "nvim_feedkeys({keys}, {mode}, {escape_ks})",
    "parameters": [
      ["String", "keys"],
      ["String", "mode"],
      ["Boolean", "escape_ks"]
    ],
    "parameters_doc": {
      "keys": "to be typed",
      "mode": "behavior flags, see |feedkeys()|",
      "escape_ks": "If true, escape K_SPECIAL bytes in `keys`\n                 This should be false if you already used\n                 |nvim_replace_termcodes()|, and true\n                 otherwise."
    },
    "doc": [
      "Sends input-keys to Nvim, subject to various quirks controlled\nby `mode` flags. This is a blocking call, unlike\n|nvim_input()|.",
      "On execution error: does not fail, but updates v:errmsg.",
      "To input sequences like <C-o> use |nvim_replace_termcodes()|\n(typically with escape_ks=false) to replace |keycodes|, then\npass the result to nvim_feedkeys().",
      "Example: >\n    :let key = nvim_replace_termcodes(\"<C-o>\", v:true, v:false, v:true)\n    :call nvim_feedkeys(key, 'n', v:false)\n\n<"
    ],
    "return": [],
    "seealso": ["feedkeys()", "vim_strsave_escape_ks"]
  },
  "nvim_get_all_options_info": {
    "annotations": [],
    "signature": "nvim_get_all_options_info({err})",
    "parameters": [["Error *", "err"]],
    "parameters_doc": {},
    "doc": [
      "Gets the option information for all options.",
      "The dictionary has the full option names as keys and option\nmetadata dictionaries as detailed at |nvim_get_option_info|."
    ],
    "return": ["dictionary of all options"],
    "seealso": []
  },
  "nvim_get_api_info": {
    "annotations": ["|api-fast|", "|RPC| only"],
    "signature": "nvim_get_api_info()",
    "parameters": [],
    "parameters_doc": {},
    "doc": [
      "Returns a 2-tuple (Array), where item 0 is the current channel\nid and item 1 is the |api-metadata| map (Dictionary)."
    ],
    "return": ["2-tuple [{channel-id}, {api-metadata}]"],
    "seealso": []
  },
  "nvim_get_autocmds": {
    "annotations": [],
    "signature": "nvim_get_autocmds({opts}, {err})",
    "parameters": [
      ["Dict(get_autocmds) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "opts": "Dictionary with at least one of the following:\n            • group (string|integer): the autocommand group\n              name or id to match against.\n            • event (string|array): event or events to match\n              against |autocmd-events|.\n            • pattern (string|array): pattern or patterns to\n              match against |autocmd-pattern|."
    },
    "doc": [
      "Get all autocommands that match the corresponding {opts}.",
      "These examples will get autocommands matching ALL the given\ncriteria: >\n  -- Matches all criteria\n  autocommands = vim.api.nvim_get_autocmds({\n    group = \"MyGroup\",\n    event = {\"BufEnter\", \"BufWinEnter\"},\n    pattern = {\"*.c\", \"*.h\"}\n  })\n\n  -- All commands from one group\n  autocommands = vim.api.nvim_get_autocmds({\n    group = \"MyGroup\",\n  })\n\n<",
      "NOTE: When multiple patterns or events are provided, it will\nfind all the autocommands that match any combination of them."
    ],
    "return": [
      "Array of autocommands matching the criteria, with each\n    item containing the following fields:\n    • id (number): the autocommand id (only when defined with\n      the API).\n    • group (integer): the autocommand group id.\n    • group_name (string): the autocommand group name.\n    • desc (string): the autocommand description.\n    • event (string): the autocommand event.\n    • command (string): the autocommand command. Note: this\n      will be empty if a callback is set.\n    • callback (function|string|nil): Lua function or name of\n      a Vim script function which is executed when this\n      autocommand is triggered.\n    • once (boolean): whether the autocommand is only run\n      once.\n    • pattern (string): the autocommand pattern. If the\n      autocommand is buffer local |autocmd-buffer-local|:\n    • buflocal (boolean): true if the autocommand is buffer\n      local.\n    • buffer (number): the buffer number.\n"
    ],
    "seealso": []
  },
  "nvim_get_chan_info": {
    "annotations": [],
    "signature": "nvim_get_chan_info({chan}, {err})",
    "parameters": [
      ["Integer", "chan"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": ["Gets information about a channel."],
    "return": [
      "Dictionary describing a channel, with these keys:\n    • \"id\" Channel id.\n    • \"argv\" (optional) Job arguments list.\n    • \"stream\" Stream underlying the channel.\n      • \"stdio\" stdin and stdout of this Nvim instance\n      • \"stderr\" stderr of this Nvim instance\n      • \"socket\" TCP/IP socket or named pipe\n      • \"job\" Job with communication over its stdio.\n\n    • \"mode\" How data received on the channel is interpreted.\n      • \"bytes\" Send and receive raw bytes.\n      • \"terminal\" |terminal| instance interprets ASCII\n        sequences.\n      • \"rpc\" |RPC| communication on the channel is active.\n\n    • \"pty\" (optional) Name of pseudoterminal. On a POSIX\n      system this is a device path like \"/dev/pts/1\". If the\n      name is unknown, the key will still be present if a pty\n      is used (e.g. for conpty on Windows).\n    • \"buffer\" (optional) Buffer with connected |terminal|\n      instance.\n    • \"client\" (optional) Info about the peer (client on the\n      other end of the RPC channel), if provided by it via\n      |nvim_set_client_info()|.\n"
    ],
    "seealso": []
  },
  "nvim_get_color_by_name": {
    "annotations": [],
    "signature": "nvim_get_color_by_name({name})",
    "parameters": [["String", "name"]],
    "parameters_doc": { "name": "Color name or \"#rrggbb\" string" },
    "doc": [
      "Returns the 24-bit RGB value of a |nvim_get_color_map()| color\nname or \"#rrggbb\" hexadecimal string.",
      "Example: >\n    :echo nvim_get_color_by_name(\"Pink\")\n    :echo nvim_get_color_by_name(\"#cbcbcb\")\n\n<"
    ],
    "return": ["24-bit RGB value, or -1 for invalid argument."],
    "seealso": []
  },
  "nvim_get_color_map": {
    "annotations": [],
    "signature": "nvim_get_color_map()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": [
      "Returns a map of color names and RGB values.",
      "Keys are color names (e.g. \"Aqua\") and values are 24-bit RGB\ncolor values (e.g. 65535)."
    ],
    "return": ["Map of color names and RGB values."],
    "seealso": []
  },
  "nvim_get_commands": {
    "annotations": [],
    "signature": "nvim_get_commands({opts}, {err})",
    "parameters": [
      ["Dict(get_commands) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "opts": "Optional parameters. Currently only supports\n            {\"builtin\":false}"
    },
    "doc": [
      "Gets a map of global (non-buffer-local) Ex commands.",
      "Currently only |user-commands| are supported, not builtin Ex\ncommands."
    ],
    "return": ["Map of maps describing commands."],
    "seealso": []
  },
  "nvim_get_context": {
    "annotations": [],
    "signature": "nvim_get_context({opts}, {err})",
    "parameters": [
      ["Dict(context) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "opts": "Optional parameters.\n            • types: List of |context-types| (\"regs\", \"jumps\",\n              \"bufs\", \"gvars\", …) to gather, or empty for\n              \"all\"."
    },
    "doc": ["Gets a map of the current editor state."],
    "return": ["map of global |context|."],
    "seealso": []
  },
  "nvim_get_current_buf": {
    "annotations": [],
    "signature": "nvim_get_current_buf()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Gets the current buffer."],
    "return": ["Buffer handle"],
    "seealso": []
  },
  "nvim_get_current_line": {
    "annotations": [],
    "signature": "nvim_get_current_line({err})",
    "parameters": [["Error *", "err"]],
    "parameters_doc": {},
    "doc": ["Gets the current line."],
    "return": ["Current line string"],
    "seealso": []
  },
  "nvim_get_current_tabpage": {
    "annotations": [],
    "signature": "nvim_get_current_tabpage()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Gets the current tabpage."],
    "return": ["Tabpage handle"],
    "seealso": []
  },
  "nvim_get_current_win": {
    "annotations": [],
    "signature": "nvim_get_current_win()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Gets the current window."],
    "return": ["Window handle"],
    "seealso": []
  },
  "nvim_get_hl_by_id": {
    "annotations": [],
    "signature": "nvim_get_hl_by_id({hl_id}, {rgb}, {err})",
    "parameters": [
      ["Integer", "hl_id"],
      ["Boolean", "rgb"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "hl_id": "Highlight id as returned by |hlID()|",
      "rgb": "Export RGB colors"
    },
    "doc": ["Gets a highlight definition by id. |hlID()|"],
    "return": ["Highlight definition map"],
    "seealso": ["nvim_get_hl_by_name"]
  },
  "nvim_get_hl_by_name": {
    "annotations": [],
    "signature": "nvim_get_hl_by_name({name}, {rgb}, {err})",
    "parameters": [
      ["String", "name"],
      ["Boolean", "rgb"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Highlight group name", "rgb": "Export RGB colors" },
    "doc": ["Gets a highlight definition by name."],
    "return": ["Highlight definition map"],
    "seealso": ["nvim_get_hl_by_id"]
  },
  "nvim_get_hl_id_by_name": {
    "annotations": [],
    "signature": "nvim_get_hl_id_by_name({name})",
    "parameters": [["String", "name"]],
    "parameters_doc": {},
    "doc": [
      "Gets a highlight group by name",
      "similar to |hlID()|, but allocates a new ID if not present."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_get_keymap": {
    "annotations": [],
    "signature": "nvim_get_keymap({mode})",
    "parameters": [["String", "mode"]],
    "parameters_doc": { "mode": "Mode short-name (\"n\", \"i\", \"v\", ...)" },
    "doc": ["Gets a list of global (non-buffer-local) |mapping|\ndefinitions."],
    "return": [
      "Array of maparg()-like dictionaries describing mappings.\n    The \"buffer\" key is always zero."
    ],
    "seealso": []
  },
  "nvim_get_mark": {
    "annotations": [],
    "signature": "nvim_get_mark({name}, {opts}, {err})",
    "parameters": [
      ["String", "name"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "name": "Mark name",
      "opts": "Optional parameters. Reserved for future use."
    },
    "doc": [
      "Return a tuple (row, col, buffer, buffername) representing the\nposition of the uppercase/file named mark. See |mark-motions|.",
      "Marks are (1,0)-indexed. |api-indexing|",
      "\nNote:\n    fails with error if a lowercase or buffer local named mark\n    is used.\n"
    ],
    "return": [
      "4-tuple (row, col, buffer, buffername), (0, 0, 0, '') if\n    the mark is not set."
    ],
    "seealso": ["|nvim_buf_set_mark()|", "|nvim_del_mark()|"]
  },
  "nvim_get_mode": {
    "annotations": ["|api-fast|"],
    "signature": "nvim_get_mode()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": [
      "Gets the current mode. |mode()| \"blocking\" is true if Nvim is\nwaiting for input."
    ],
    "return": ["Dictionary { \"mode\": String, \"blocking\": Boolean }"],
    "seealso": []
  },
  "nvim_get_namespaces": {
    "annotations": [],
    "signature": "nvim_get_namespaces()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Gets existing, non-anonymous namespaces."],
    "return": ["dict that maps from names to namespace ids."],
    "seealso": []
  },
  "nvim_get_option": {
    "annotations": [],
    "signature": "nvim_get_option({name}, {err})",
    "parameters": [
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Option name" },
    "doc": ["Gets the global value of an option."],
    "return": ["Option value (global)"],
    "seealso": []
  },
  "nvim_get_option_info": {
    "annotations": [],
    "signature": "nvim_get_option_info({name}, {err})",
    "parameters": [
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Option name" },
    "doc": [
      "Gets the option information for one option",
      "Resulting dictionary has keys:\n• name: Name of the option (like 'filetype')\n• shortname: Shortened name of the option (like 'ft')\n• type: type of option (\"string\", \"number\" or \"boolean\")\n• default: The default value for the option\n• was_set: Whether the option was set.\n• last_set_sid: Last set script id (if any)\n• last_set_linenr: line number where option was set\n• last_set_chan: Channel where option was set (0 for local)\n• scope: one of \"global\", \"win\", or \"buf\"\n• global_local: whether win or buf option has a global value\n• commalist: List of comma separated values\n• flaglist: List of single char flags\n"
    ],
    "return": ["Option Information"],
    "seealso": []
  },
  "nvim_get_option_value": {
    "annotations": [],
    "signature": "nvim_get_option_value({name}, {opts}, {err})",
    "parameters": [
      ["String", "name"],
      ["Dict(option) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "name": "Option name",
      "opts": "Optional parameters\n            • scope: One of \"global\" or \"local\". Analogous to\n              |:setglobal| and |:setlocal|, respectively.\n            • win: |window-ID|. Used for getting window local\n              options.\n            • buf: Buffer number. Used for getting buffer\n              local options. Implies {scope} is \"local\"."
    },
    "doc": [
      "Gets the value of an option. The behavior of this function\nmatches that of |:set|: the local value of an option is\nreturned if it exists; otherwise, the global value is\nreturned. Local values always correspond to the current buffer\nor window, unless \"buf\" or \"win\" is set in {opts}."
    ],
    "return": ["Option value"],
    "seealso": []
  },
  "nvim_get_proc": {
    "annotations": [],
    "signature": "nvim_get_proc({pid}, {err})",
    "parameters": [
      ["Integer", "pid"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": ["Gets info describing process `pid`."],
    "return": ["Map of process properties, or NIL if process not found."],
    "seealso": []
  },
  "nvim_get_proc_children": {
    "annotations": [],
    "signature": "nvim_get_proc_children({pid}, {err})",
    "parameters": [
      ["Integer", "pid"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": ["Gets the immediate children of process `pid`."],
    "return": ["Array of child process ids, empty if process not found."],
    "seealso": []
  },
  "nvim_get_runtime_file": {
    "annotations": ["|api-fast|"],
    "signature": "nvim_get_runtime_file({name}, {all}, {err})",
    "parameters": [
      ["String", "name"],
      ["Boolean", "all"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "name": "pattern of files to search for",
      "all": "whether to return all matches or only the first"
    },
    "doc": [
      "Find files in runtime directories",
      "'name' can contain wildcards. For example\nnvim_get_runtime_file(\"colors/*.vim\", true) will return all\ncolor scheme files. Always use forward slashes (/) in the\nsearch pattern for subdirectories regardless of platform.",
      "It is not an error to not find any files. An empty array is\nreturned then."
    ],
    "return": ["list of absolute paths to the found files"],
    "seealso": []
  },
  "nvim_get_var": {
    "annotations": [],
    "signature": "nvim_get_var({name}, {err})",
    "parameters": [
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Variable name" },
    "doc": ["Gets a global (g:) variable."],
    "return": ["Variable value"],
    "seealso": []
  },
  "nvim_get_vvar": {
    "annotations": [],
    "signature": "nvim_get_vvar({name}, {err})",
    "parameters": [
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Variable name" },
    "doc": ["Gets a v: variable."],
    "return": ["Variable value"],
    "seealso": []
  },
  "nvim_input": {
    "annotations": ["|api-fast|"],
    "signature": "nvim_input({keys})",
    "parameters": [["String", "keys"]],
    "parameters_doc": { "keys": "to be typed" },
    "doc": [
      "Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a\nlow-level input buffer and the call is non-blocking (input is\nprocessed asynchronously by the eventloop).",
      "On execution error: does not fail, but updates v:errmsg.",
      "\nNote:\n    |keycodes| like <CR> are translated, so \"<\" is special. To\n    input a literal \"<\", send <LT>.\n\nNote:\n    For mouse events use |nvim_input_mouse()|. The pseudokey\n    form \"<LeftMouse><col,row>\" is deprecated since\n    |api-level| 6.\n"
    ],
    "return": [
      "Number of bytes actually written (can be fewer than\n    requested if the buffer becomes full)."
    ],
    "seealso": []
  },
  "nvim_input_mouse": {
    "annotations": ["|api-fast|"],
    "signature": "nvim_input_mouse({button}, {action}, {modifier}, {grid}, {row}, {col}, {err})",
    "parameters": [
      ["String", "button"],
      ["String", "action"],
      ["String", "modifier"],
      ["Integer", "grid"],
      ["Integer", "row"],
      ["Integer", "col"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "button": "Mouse button: one of \"left\", \"right\",\n                \"middle\", \"wheel\".",
      "action": "For ordinary buttons, one of \"press\", \"drag\",\n                \"release\". For the wheel, one of \"up\", \"down\",\n                \"left\", \"right\".",
      "modifier": "String of modifiers each represented by a\n                single char. The same specifiers are used as\n                for a key press, except that the \"-\" separator\n                is optional, so \"C-A-\", \"c-a\" and \"CA\" can all\n                be used to specify Ctrl+Alt+click.",
      "grid": "Grid number if the client uses |ui-multigrid|,\n                else 0.",
      "row": "Mouse row-position (zero-based, like redraw\n                events)",
      "col": "Mouse column-position (zero-based, like redraw\n                events)"
    },
    "doc": [
      "Send mouse event from GUI.",
      "Non-blocking: does not wait on any result, but queues the\nevent to be processed soon by the event loop.",
      "\nNote:\n    Currently this doesn't support \"scripting\" multiple mouse\n    events by calling it multiple times in a loop: the\n    intermediate mouse positions will be ignored. It should be\n    used to implement real-time mouse input in a GUI. The\n    deprecated pseudokey form (\"<LeftMouse><col,row>\") of\n    |nvim_input()| has the same limitation.\n"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_list_bufs": {
    "annotations": [],
    "signature": "nvim_list_bufs()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": [
      "Gets the current list of buffer handles",
      "Includes unlisted (unloaded/deleted) buffers, like `:ls!`. Use\n|nvim_buf_is_loaded()| to check if a buffer is loaded."
    ],
    "return": ["List of buffer handles"],
    "seealso": []
  },
  "nvim_list_chans": {
    "annotations": [],
    "signature": "nvim_list_chans()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Get information about all open channels."],
    "return": [
      "Array of Dictionaries, each describing a channel with the\n    format specified at |nvim_get_chan_info()|."
    ],
    "seealso": []
  },
  "nvim_list_runtime_paths": {
    "annotations": [],
    "signature": "nvim_list_runtime_paths({err})",
    "parameters": [["Error *", "err"]],
    "parameters_doc": {},
    "doc": ["Gets the paths contained in 'runtimepath'."],
    "return": ["List of paths"],
    "seealso": []
  },
  "nvim_list_tabpages": {
    "annotations": [],
    "signature": "nvim_list_tabpages()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Gets the current list of tabpage handles."],
    "return": ["List of tabpage handles"],
    "seealso": []
  },
  "nvim_list_uis": {
    "annotations": [],
    "signature": "nvim_list_uis()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Gets a list of dictionaries representing attached UIs."],
    "return": [
      "Array of UI dictionaries, each with these keys:\n    • \"height\" Requested height of the UI\n    • \"width\" Requested width of the UI\n    • \"rgb\" true if the UI uses RGB colors (false implies\n      |cterm-colors|)\n    • \"ext_...\" Requested UI extensions, see |ui-option|\n    • \"chan\" Channel id of remote UI (not present for TUI)\n"
    ],
    "seealso": []
  },
  "nvim_list_wins": {
    "annotations": [],
    "signature": "nvim_list_wins()",
    "parameters": [["void", ""]],
    "parameters_doc": {},
    "doc": ["Gets the current list of window handles."],
    "return": ["List of window handles"],
    "seealso": []
  },
  "nvim_load_context": {
    "annotations": [],
    "signature": "nvim_load_context({dict})",
    "parameters": [["Dictionary", "dict"]],
    "parameters_doc": { "dict": "|Context| map." },
    "doc": ["Sets the current editor state from the given |context| map."],
    "return": [],
    "seealso": []
  },
  "nvim_notify": {
    "annotations": [],
    "signature": "nvim_notify({msg}, {log_level}, {opts}, {err})",
    "parameters": [
      ["String", "msg"],
      ["Integer", "log_level"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "msg": "Message to display to the user",
      "log_level": "The log level",
      "opts": "Reserved for future use."
    },
    "doc": [
      "Notify the user with a message",
      "Relays the call to vim.notify . By default forwards your\nmessage in the echo area but can be overridden to trigger\ndesktop notifications."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_open_term": {
    "annotations": [],
    "signature": "nvim_open_term({buffer}, {opts}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["DictionaryOf(LuaRef)", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "the buffer to use (expected to be empty)",
      "opts": "Optional parameters.\n              • on_input: lua callback for input sent, i e\n                keypresses in terminal mode. Note: keypresses\n                are sent raw as they would be to the pty\n                master end. For instance, a carriage return is\n                sent as a \"\\r\", not as a \"\\n\". |textlock|\n                applies. It is possible to call\n                |nvim_chan_send| directly in the callback\n                however. [\"input\", term, bufnr, data]"
    },
    "doc": [
      "Open a terminal instance in a buffer",
      "By default (and currently the only option) the terminal will\nnot be connected to an external process. Instead, input send\non the channel will be echoed directly by the terminal. This\nis useful to display ANSI terminal sequences returned as part\nof a rpc message, or similar.",
      "Note: to directly initiate the terminal using the right size,\ndisplay the buffer in a configured window before calling this.\nFor instance, for a floating display, first create an empty\nbuffer using |nvim_create_buf()|, then display it using\n|nvim_open_win()|, and then call this function. Then\n|nvim_chan_send()| can be called immediately to process\nsequences in a virtual terminal having the intended size."
    ],
    "return": ["Channel id, or 0 on error"],
    "seealso": []
  },
  "nvim_open_win": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_open_win({buffer}, {enter}, {config}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Boolean", "enter"],
      ["Dict(float_config) *", "config"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "buffer": "Buffer to display, or 0 for current buffer",
      "enter": "Enter the window (make it the current window)",
      "config": "Map defining the window configuration. Keys:\n              • relative: Sets the window layout to\n                \"floating\", placed at (row,col) coordinates\n                relative to:\n                • \"editor\" The global editor grid\n                • \"win\" Window given by the `win` field, or\n                  current window.\n                • \"cursor\" Cursor position in current window.\n\n              • win: |window-ID| for relative=\"win\".\n              • anchor: Decides which corner of the float to\n                place at (row,col):\n                • \"NW\" northwest (default)\n                • \"NE\" northeast\n                • \"SW\" southwest\n                • \"SE\" southeast\n\n              • width: Window width (in character cells).\n                Minimum of 1.\n              • height: Window height (in character cells).\n                Minimum of 1.\n              • bufpos: Places float relative to buffer text\n                (only when relative=\"win\"). Takes a tuple of\n                zero-indexed [line, column]. `row` and `col` if given are applied relative to this\n                position, else they default to:\n                • `row=1` and `col=0` if `anchor` is \"NW\" or\n                  \"NE\"\n                • `row=0` and `col=0` if `anchor` is \"SW\" or\n                  \"SE\" (thus like a tooltip near the buffer\n                  text).\n\n              • row: Row position in units of \"screen cell\n                height\", may be fractional.\n              • col: Column position in units of \"screen cell\n                width\", may be fractional.\n              • focusable: Enable focus by user actions\n                (wincmds, mouse events). Defaults to true.\n                Non-focusable windows can be entered by\n                |nvim_set_current_win()|.\n              • external: GUI should display the window as an\n                external top-level window. Currently accepts\n                no other positioning configuration together\n                with this.\n              • zindex: Stacking order. floats with higher `zindex` go on top on floats with lower indices. Must\n                be larger than zero. The following screen\n                elements have hard-coded z-indices:\n                • 100: insert completion popupmenu\n                • 200: message scrollback\n                • 250: cmdline completion popupmenu (when\n                  wildoptions+=pum) The default value for\n                  floats are 50. In general, values below 100\n                  are recommended, unless there is a good\n                  reason to overshadow builtin elements.\n\n              • style: Configure the appearance of the window.\n                Currently only takes one non-empty value:\n                • \"minimal\" Nvim will display the window with\n                  many UI options disabled. This is useful\n                  when displaying a temporary float where the\n                  text should not be edited. Disables\n                  'number', 'relativenumber', 'cursorline',\n                  'cursorcolumn', 'foldcolumn', 'spell' and\n                  'list' options. 'signcolumn' is changed to\n                  `auto` and 'colorcolumn' is cleared. The\n                  end-of-buffer region is hidden by setting\n                  `eob` flag of 'fillchars' to a space char,\n                  and clearing the |EndOfBuffer| region in\n                  'winhighlight'.\n\n              • border: Style of (optional) window border.\n                This can either be a string or an array. The\n                string values are\n                • \"none\": No border (default).\n                • \"single\": A single line box.\n                • \"double\": A double line box.\n                • \"rounded\": Like \"single\", but with rounded\n                  corners (\"╭\" etc.).\n                • \"solid\": Adds padding by a single whitespace\n                  cell.\n                • \"shadow\": A drop shadow effect by blending\n                  with the background.\n                • If it is an array, it should have a length\n                  of eight or any divisor of eight. The array\n                  will specifify the eight chars building up\n                  the border in a clockwise fashion starting\n                  with the top-left corner. As an example, the\n                  double box style could be specified as [\n                  \"╔\", \"═\" ,\"╗\", \"║\", \"╝\", \"═\", \"╚\", \"║\" ]. If\n                  the number of chars are less than eight,\n                  they will be repeated. Thus an ASCII border\n                  could be specified as [ \"/\", \"-\", \"\\\\\", \"|\"\n                  ], or all chars the same as [ \"x\" ]. An\n                  empty string can be used to turn off a\n                  specific border, for instance, [ \"\", \"\", \"\",\n                  \">\", \"\", \"\", \"\", \"<\" ] will only make\n                  vertical borders but not horizontal ones. By\n                  default, `FloatBorder` highlight is used,\n                  which links to `WinSeparator` when not\n                  defined. It could also be specified by\n                  character: [ {\"+\", \"MyCorner\"}, {\"x\",\n                  \"MyBorder\"} ].\n\n              • noautocmd: If true then no buffer-related\n                autocommand events such as |BufEnter|,\n                |BufLeave| or |BufWinEnter| may fire from\n                calling this function."
    },
    "doc": [
      "Open a new window.",
      "Currently this is used to open floating and external windows.\nFloats are windows that are drawn above the split layout, at\nsome anchor position in some other window. Floats can be drawn\ninternally or by external GUI with the |ui-multigrid|\nextension. External windows are only supported with multigrid\nGUIs, and are displayed as separate top-level windows.",
      "For a general overview of floats, see |api-floatwin|.",
      "Exactly one of `external` and `relative` must be specified.\nThe `width` and `height` of the new window must be specified.",
      "With relative=editor (row=0,col=0) refers to the top-left\ncorner of the screen-grid and (row=Lines-1,col=Columns-1)\nrefers to the bottom-right corner. Fractional values are\nallowed, but the builtin implementation (used by non-multigrid\nUIs) will always round down to nearest integer.",
      "Out-of-bounds values, and configurations that make the float\nnot fit inside the main editor, are allowed. The builtin\nimplementation truncates values so floats are fully within the\nmain screen grid. External GUIs could let floats hover outside\nof the main window like a tooltip, but this should not be used\nto specify arbitrary WM screen positions.",
      "Example (Lua): window-relative float >\n    vim.api.nvim_open_win(0, false,\n      {relative='win', row=3, col=3, width=12, height=3})\n\n<",
      "Example (Lua): buffer-relative float (travels as buffer is\nscrolled) >\n    vim.api.nvim_open_win(0, false,\n      {relative='win', width=12, height=3, bufpos={100,10}})\n\n<"
    ],
    "return": ["Window handle, or 0 on error"],
    "seealso": []
  },
  "nvim_out_write": {
    "annotations": [],
    "signature": "nvim_out_write({str})",
    "parameters": [["String", "str"]],
    "parameters_doc": { "str": "Message" },
    "doc": [
      "Writes a message to the Vim output buffer. Does not append\n\"\\n\", the message is buffered (won't display) until a linefeed\nis written."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_parse_cmd": {
    "annotations": ["|api-fast|"],
    "signature": "nvim_parse_cmd({str}, {opts}, {err})",
    "parameters": [
      ["String", "str"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "str": "Command line string to parse. Cannot contain \"\\n\".",
      "opts": "Optional parameters. Reserved for future use."
    },
    "doc": ["Parse command line.", "Doesn't check the validity of command arguments."],
    "return": [
      "Dictionary containing command information, with these\n    keys:\n    • cmd: (string) Command name.\n    • range: (array) Command <range>. Can have 0-2 elements\n      depending on how many items the range contains. Has no\n      elements if command doesn't accept a range or if no\n      range was specified, one element if only a single range\n      item was specified and two elements if both range items\n      were specified.\n    • count: (number) Any |<count>| that was supplied to the\n      command. -1 if command cannot take a count.\n    • reg: (number) The optional command |<register>|, if\n      specified. Empty string if not specified or if command\n      cannot take a register.\n    • bang: (boolean) Whether command contains a |<bang>| (!)\n      modifier.\n    • args: (array) Command arguments.\n    • addr: (string) Value of |:command-addr|. Uses short\n      name.\n    • nargs: (string) Value of |:command-nargs|.\n    • nextcmd: (string) Next command if there are multiple\n      commands separated by a |:bar|. Empty if there isn't a\n      next command.\n    • magic: (dictionary) Which characters have special\n      meaning in the command arguments.\n      • file: (boolean) The command expands filenames. Which\n        means characters such as \"%\", \"#\" and wildcards are\n        expanded.\n      • bar: (boolean) The \"|\" character is treated as a\n        command separator and the double quote character (\")\n        is treated as the start of a comment.\n\n    • mods: (dictionary) |:command-modifiers|.\n      • filter: (dictionary) |:filter|.\n        • pattern: (string) Filter pattern. Empty string if\n          there is no filter.\n        • force: (boolean) Whether filter is inverted or not.\n\n      • silent: (boolean) |:silent|.\n      • emsg_silent: (boolean) |:silent!|.\n      • sandbox: (boolean) |:sandbox|.\n      • noautocmd: (boolean) |:noautocmd|.\n      • browse: (boolean) |:browse|.\n      • confirm: (boolean) |:confirm|.\n      • hide: (boolean) |:hide|.\n      • keepalt: (boolean) |:keepalt|.\n      • keepjumps: (boolean) |:keepjumps|.\n      • keepmarks: (boolean) |:keepmarks|.\n      • keeppatterns: (boolean) |:keeppatterns|.\n      • lockmarks: (boolean) |:lockmarks|.\n      • noswapfile: (boolean) |:noswapfile|.\n      • tab: (integer) |:tab|.\n      • verbose: (integer) |:verbose|. -1 when omitted.\n      • vertical: (boolean) |:vertical|.\n      • split: (string) Split modifier string, is an empty\n        string when there's no split modifier. If there is a\n        split modifier it can be one of:\n        • \"aboveleft\": |:aboveleft|.\n        • \"belowright\": |:belowright|.\n        • \"topleft\": |:topleft|.\n        • \"botright\": |:botright|.\n\n\n"
    ],
    "seealso": []
  },
  "nvim_parse_expression": {
    "annotations": ["|api-fast|"],
    "signature": "nvim_parse_expression({expr}, {flags}, {highlight}, {err})",
    "parameters": [
      ["String", "expr"],
      ["String", "flags"],
      ["Boolean", "highlight"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "expr": "Expression to parse. Always treated as a\n                 single line.",
      "flags": "Flags:\n                 • \"m\" if multiple expressions in a row are\n                   allowed (only the first one will be\n                   parsed),\n                 • \"E\" if EOC tokens are not allowed\n                   (determines whether they will stop parsing\n                   process or be recognized as an\n                   operator/space, though also yielding an\n                   error).\n                 • \"l\" when needing to start parsing with\n                   lvalues for \":let\" or \":for\". Common flag\n                   sets:\n                 • \"m\" to parse like for \":echo\".\n                 • \"E\" to parse like for \"<C-r>=\".\n                 • empty string for \":call\".\n                 • \"lm\" to parse for \":let\".",
      "highlight": "If true, return value will also include\n                 \"highlight\" key containing array of 4-tuples\n                 (arrays) (Integer, Integer, Integer, String),\n                 where first three numbers define the\n                 highlighted region and represent line,\n                 starting column and ending column (latter\n                 exclusive: one should highlight region\n                 [start_col, end_col))."
    },
    "doc": ["Parse a VimL expression."],
    "return": [
      "\n    • AST: top-level dictionary with these keys:\n      • \"error\": Dictionary with error, present only if parser\n        saw some error. Contains the following keys:\n        • \"message\": String, error message in printf format,\n          translated. Must contain exactly one \"%.*s\".\n        • \"arg\": String, error message argument.\n\n      • \"len\": Amount of bytes successfully parsed. With flags\n        equal to \"\" that should be equal to the length of expr\n        string. (“Successfully parsed” here means\n        “participated in AST creation”, not “till the first\n        error”.)\n      • \"ast\": AST, either nil or a dictionary with these\n        keys:\n        • \"type\": node type, one of the value names from\n          ExprASTNodeType stringified without \"kExprNode\"\n          prefix.\n        • \"start\": a pair [line, column] describing where node\n          is \"started\" where \"line\" is always 0 (will not be 0\n          if you will be using nvim_parse_viml() on e.g.\n          \":let\", but that is not present yet). Both elements\n          are Integers.\n        • \"len\": “length” of the node. This and \"start\" are\n          there for debugging purposes primary (debugging\n          parser and providing debug information).\n        • \"children\": a list of nodes described in top/\"ast\".\n          There always is zero, one or two children, key will\n          not be present if node has no children. Maximum\n          number of children may be found in node_maxchildren\n          array.\n\n\n    • Local values (present only for certain nodes):\n      • \"scope\": a single Integer, specifies scope for\n        \"Option\" and \"PlainIdentifier\" nodes. For \"Option\" it\n        is one of ExprOptScope values, for \"PlainIdentifier\"\n        it is one of ExprVarScope values.\n      • \"ident\": identifier (without scope, if any), present\n        for \"Option\", \"PlainIdentifier\", \"PlainKey\" and\n        \"Environment\" nodes.\n      • \"name\": Integer, register name (one character) or -1.\n        Only present for \"Register\" nodes.\n      • \"cmp_type\": String, comparison type, one of the value\n        names from ExprComparisonType, stringified without\n        \"kExprCmp\" prefix. Only present for \"Comparison\"\n        nodes.\n      • \"ccs_strategy\": String, case comparison strategy, one\n        of the value names from ExprCaseCompareStrategy,\n        stringified without \"kCCStrategy\" prefix. Only present\n        for \"Comparison\" nodes.\n      • \"augmentation\": String, augmentation type for\n        \"Assignment\" nodes. Is either an empty string, \"Add\",\n        \"Subtract\" or \"Concat\" for \"=\", \"+=\", \"-=\" or \".=\"\n        respectively.\n      • \"invert\": Boolean, true if result of comparison needs\n        to be inverted. Only present for \"Comparison\" nodes.\n      • \"ivalue\": Integer, integer value for \"Integer\" nodes.\n      • \"fvalue\": Float, floating-point value for \"Float\"\n        nodes.\n      • \"svalue\": String, value for \"SingleQuotedString\" and\n        \"DoubleQuotedString\" nodes.\n\n"
    ],
    "seealso": []
  },
  "nvim_paste": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_paste({data}, {crlf}, {phase}, {err})",
    "parameters": [
      ["String", "data"],
      ["Boolean", "crlf"],
      ["Integer", "phase"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "data": "Multiline input. May be binary (containing NUL\n             bytes).",
      "crlf": "Also break lines at CR and CRLF.",
      "phase": "-1: paste in a single call (i.e. without\n             streaming). To \"stream\" a paste, call `nvim_paste` sequentially with these `phase` values:\n             • 1: starts the paste (exactly once)\n             • 2: continues the paste (zero or more times)\n             • 3: ends the paste (exactly once)"
    },
    "doc": [
      "Pastes at cursor, in any mode.",
      "Invokes the `vim.paste` handler, which handles each mode\nappropriately. Sets redo/undo. Faster than |nvim_input()|.\nLines break at LF (\"\\n\").",
      "Errors ('nomodifiable', `vim.paste()` failure, …) are\nreflected in `err` but do not affect the return value (which\nis strictly decided by `vim.paste()`). On error, subsequent\ncalls are ignored (\"drained\") until the next paste is\ninitiated (phase 1 or -1)."
    ],
    "return": [
      "\n    • true: Client may continue pasting.\n    • false: Client must cancel the paste.\n"
    ],
    "seealso": []
  },
  "nvim_put": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_put({lines}, {type}, {after}, {follow}, {err})",
    "parameters": [
      ["ArrayOf(String)", "lines"],
      ["String", "type"],
      ["Boolean", "after"],
      ["Boolean", "follow"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "lines": "|readfile()|-style list of lines.\n              |channel-lines|",
      "type": "Edit behavior: any |getregtype()| result, or:\n              • \"b\" |blockwise-visual| mode (may include\n                width, e.g. \"b3\")\n              • \"c\" |charwise| mode\n              • \"l\" |linewise| mode\n              • \"\" guess by contents, see |setreg()|",
      "after": "If true insert after cursor (like |p|), or\n              before (like |P|).",
      "follow": "If true place cursor at end of inserted text."
    },
    "doc": [
      "Puts text at cursor, in any mode.",
      "Compare |:put| and |p| which are always linewise."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_replace_termcodes": {
    "annotations": [],
    "signature": "nvim_replace_termcodes({str}, {from_part}, {do_lt}, {special})",
    "parameters": [
      ["String", "str"],
      ["Boolean", "from_part"],
      ["Boolean", "do_lt"],
      ["Boolean", "special"]
    ],
    "parameters_doc": {
      "str": "String to be converted.",
      "from_part": "Legacy Vim parameter. Usually true.",
      "do_lt": "Also translate <lt>. Ignored if `special` is\n                 false.",
      "special": "Replace |keycodes|, e.g. <CR> becomes a \"\\r\"\n                 char."
    },
    "doc": [
      "Replaces terminal codes and |keycodes| (<CR>, <Esc>, ...) in a\nstring with the internal representation."
    ],
    "return": [],
    "seealso": ["replace_termcodes", "cpoptions"]
  },
  "nvim_select_popupmenu_item": {
    "annotations": [],
    "signature": "nvim_select_popupmenu_item({item}, {insert}, {finish}, {opts}, {err})",
    "parameters": [
      ["Integer", "item"],
      ["Boolean", "insert"],
      ["Boolean", "finish"],
      ["Dictionary", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "item": "Index (zero-based) of the item to select. Value\n              of -1 selects nothing and restores the original\n              text.",
      "insert": "Whether the selection should be inserted in the\n              buffer.",
      "finish": "Finish the completion and dismiss the popupmenu.\n              Implies `insert`.",
      "opts": "Optional parameters. Reserved for future use."
    },
    "doc": [
      "Selects an item in the completion popupmenu.",
      "If |ins-completion| is not active this API call is silently\nignored. Useful for an external UI using |ui-popupmenu| to\ncontrol the popupmenu with the mouse. Can also be used in a\nmapping; use <cmd> |:map-cmd| to ensure the mapping doesn't\nend completion mode."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_set_client_info": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_set_client_info({name}, {version}, {type}, {methods}, {attributes}, {err})",
    "parameters": [
      ["String", "name"],
      ["Dictionary", "version"],
      ["String", "type"],
      ["Dictionary", "methods"],
      ["Dictionary", "attributes"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "name": "Short name for the connected client",
      "version": "Dictionary describing the version, with\n                  these (optional) keys:\n                  • \"major\" major version (defaults to 0 if\n                    not set, for no release yet)\n                  • \"minor\" minor version\n                  • \"patch\" patch number\n                  • \"prerelease\" string describing a\n                    prerelease, like \"dev\" or \"beta1\"\n                  • \"commit\" hash or similar identifier of\n                    commit",
      "type": "Must be one of the following values. Client\n                  libraries should default to \"remote\" unless\n                  overridden by the user.\n                  • \"remote\" remote client connected to Nvim.\n                  • \"ui\" gui frontend\n                  • \"embedder\" application using Nvim as a\n                    component (for example, IDE/editor\n                    implementing a vim mode).\n                  • \"host\" plugin host, typically started by\n                    nvim\n                  • \"plugin\" single plugin, started by nvim",
      "methods": "Builtin methods in the client. For a host,\n                  this does not include plugin methods which\n                  will be discovered later. The key should be\n                  the method name, the values are dicts with\n                  these (optional) keys (more keys may be\n                  added in future versions of Nvim, thus\n                  unknown keys are ignored. Clients must only\n                  use keys defined in this or later versions\n                  of Nvim):\n                  • \"async\" if true, send as a notification.\n                    If false or unspecified, use a blocking\n                    request\n                  • \"nargs\" Number of arguments. Could be a\n                    single integer or an array of two\n                    integers, minimum and maximum inclusive.",
      "attributes": "Arbitrary string:string map of informal\n                  client properties. Suggested keys:\n                  • \"website\": Client homepage URL (e.g.\n                    GitHub repository)\n                  • \"license\": License description (\"Apache\n                    2\", \"GPLv3\", \"MIT\", …)\n                  • \"logo\": URI or path to image, preferably\n                    small logo or icon. .png or .svg format is\n                    preferred."
    },
    "doc": [
      "Self-identifies the client.",
      "The client/plugin/application should call this after\nconnecting, to provide hints about its identity and purpose,\nfor debugging and orchestration.",
      "Can be called more than once; the caller should merge old info\nif appropriate. Example: library first identifies the channel,\nthen a plugin using that library later identifies itself.",
      "\nNote:\n    \"Something is better than nothing\". You don't need to\n    include all the fields.\n"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_set_current_buf": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_set_current_buf({buffer}, {err})",
    "parameters": [
      ["Buffer", "buffer"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "buffer": "Buffer handle" },
    "doc": ["Sets the current buffer."],
    "return": [],
    "seealso": []
  },
  "nvim_set_current_dir": {
    "annotations": [],
    "signature": "nvim_set_current_dir({dir}, {err})",
    "parameters": [
      ["String", "dir"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "dir": "Directory path" },
    "doc": ["Changes the global working directory."],
    "return": [],
    "seealso": []
  },
  "nvim_set_current_line": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_set_current_line({line}, {err})",
    "parameters": [
      ["String", "line"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "line": "Line contents" },
    "doc": ["Sets the current line."],
    "return": [],
    "seealso": []
  },
  "nvim_set_current_tabpage": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_set_current_tabpage({tabpage}, {err})",
    "parameters": [
      ["Tabpage", "tabpage"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "tabpage": "Tabpage handle" },
    "doc": ["Sets the current tabpage."],
    "return": [],
    "seealso": []
  },
  "nvim_set_current_win": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_set_current_win({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle" },
    "doc": ["Sets the current window."],
    "return": [],
    "seealso": []
  },
  "nvim_set_decoration_provider": {
    "annotations": ["|vim.api| only"],
    "signature": "nvim_set_decoration_provider({ns_id}, {opts}, {err})",
    "parameters": [
      ["Integer", "ns_id"],
      ["DictionaryOf(LuaRef)", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "ns_id": "Namespace id from |nvim_create_namespace()|",
      "opts": "Callbacks invoked during redraw:\n             • on_start: called first on each screen redraw\n               [\"start\", tick]\n             • on_buf: called for each buffer being redrawn\n               (before window callbacks) [\"buf\", bufnr, tick]\n             • on_win: called when starting to redraw a\n               specific window. [\"win\", winid, bufnr, topline,\n               botline_guess]\n             • on_line: called for each buffer line being\n               redrawn. (The interaction with fold lines is\n               subject to change) [\"win\", winid, bufnr, row]\n             • on_end: called at the end of a redraw cycle\n               [\"end\", tick]"
    },
    "doc": [
      "Set or change decoration provider for a namespace",
      "This is a very general purpose interface for having lua\ncallbacks being triggered during the redraw code.",
      "The expected usage is to set extmarks for the currently\nredrawn buffer. |nvim_buf_set_extmark| can be called to add\nmarks on a per-window or per-lines basis. Use the `ephemeral`\nkey to only use the mark for the current screen redraw (the\ncallback will be called again for the next redraw ).",
      "Note: this function should not be called often. Rather, the\ncallbacks themselves can be used to throttle unneeded\ncallbacks. the `on_start` callback can return `false` to\ndisable the provider until the next redraw. Similarly, return\n`false` in `on_win` will skip the `on_lines` calls for that\nwindow (but any extmarks set in `on_win` will still be used).\nA plugin managing multiple sources of decoration should\nideally only set one provider, and merge the sources\ninternally. You can use multiple `ns_id` for the extmarks\nset/modified inside the callback anyway.",
      "Note: doing anything other than setting extmarks is considered\nexperimental. Doing things like changing options are not\nexpliticly forbidden, but is likely to have unexpected\nconsequences (such as 100% CPU consumption). doing\n`vim.rpcnotify` should be OK, but `vim.rpcrequest` is quite\ndubious for the moment."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_set_hl": {
    "annotations": [],
    "signature": "nvim_set_hl({ns_id}, {name}, {val}, {err})",
    "parameters": [
      ["Integer", "ns_id"],
      ["String", "name"],
      ["Dict(highlight) *", "val"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "ns_id": "Namespace id for this highlight\n             |nvim_create_namespace()|. Use 0 to set a\n             highlight group globally |:highlight|.",
      "name": "Highlight group name, e.g. \"ErrorMsg\"",
      "val": "Highlight definition map, accepts the following\n             keys:\n             • fg (or foreground): color name or \"#RRGGBB\",\n               see note.\n             • bg (or background): color name or \"#RRGGBB\",\n               see note.\n             • sp (or special): color name or \"#RRGGBB\"\n             • blend: integer between 0 and 100\n             • bold: boolean\n             • standout: boolean\n             • underline: boolean\n             • underlineline: boolean\n             • undercurl: boolean\n             • underdot: boolean\n             • underdash: boolean\n             • strikethrough: boolean\n             • italic: boolean\n             • reverse: boolean\n             • nocombine: boolean\n             • link: name of another highlight group to link\n               to, see |:hi-link|.\n             • default: Don't override existing definition\n               |:hi-default|\n             • ctermfg: Sets foreground of cterm color\n               |highlight-ctermfg|\n             • ctermbg: Sets background of cterm color\n               |highlight-ctermbg|\n             • cterm: cterm attribute map, like\n               |highlight-args|. If not set, cterm attributes\n               will match those from the attribute map\n               documented above."
    },
    "doc": [
      "Sets a highlight group.",
      "\nNote:\n    Unlike the `:highlight` command which can update a\n    highlight group, this function completely replaces the\n    definition. For example: `nvim_set_hl(0, 'Visual', {})`\n    will clear the highlight group 'Visual'.\n\nNote:\n    The fg and bg keys also accept the string values `\"fg\"` or\n    `\"bg\"` which act as aliases to the corresponding\n    foreground and background values of the Normal group. If\n    the Normal group has not been defined, using these values\n    results in an error.\n"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_set_keymap": {
    "annotations": [],
    "signature": "nvim_set_keymap({mode}, {lhs}, {rhs}, {opts}, {err})",
    "parameters": [
      ["String", "mode"],
      ["String", "lhs"],
      ["String", "rhs"],
      ["Dict(keymap) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "mode": "Mode short-name (map command prefix: \"n\", \"i\",\n            \"v\", \"x\", …) or \"!\" for |:map!|, or empty string\n            for |:map|.",
      "lhs": "Left-hand-side |{lhs}| of the mapping.",
      "rhs": "Right-hand-side |{rhs}| of the mapping.",
      "opts": "Optional parameters map: keys are\n            |:map-arguments|, values are booleans (default\n            false). Accepts all |:map-arguments| as keys\n            excluding |<buffer>| but including |noremap| and\n            \"desc\". Unknown key is an error. \"desc\" can be\n            used to give a description to the mapping. When\n            called from Lua, also accepts a \"callback\" key\n            that takes a Lua function to call when the mapping\n            is executed."
    },
    "doc": [
      "Sets a global |mapping| for the given mode.",
      "To set a buffer-local mapping, use |nvim_buf_set_keymap()|.",
      "Unlike |:map|, leading/trailing whitespace is accepted as part\nof the {lhs} or {rhs}. Empty {rhs} is |<Nop>|. |keycodes| are\nreplaced as usual.",
      "Example: >\n    call nvim_set_keymap('n', ' <NL>', '', {'nowait': v:true})\n\n<",
      "is equivalent to: >\n    nmap <nowait> <Space><NL> <Nop>\n\n<"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_set_option": {
    "annotations": [],
    "signature": "nvim_set_option({name}, {value}, {err})",
    "parameters": [
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Option name", "value": "New option value" },
    "doc": ["Sets the global value of an option."],
    "return": [],
    "seealso": []
  },
  "nvim_set_option_value": {
    "annotations": [],
    "signature": "nvim_set_option_value({name}, {value}, {opts}, {err})",
    "parameters": [
      ["String", "name"],
      ["Object", "value"],
      ["Dict(option) *", "opts"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "name": "Option name",
      "value": "New option value",
      "opts": "Optional parameters\n             • scope: One of 'global' or 'local'. Analogous to\n               |:setglobal| and |:setlocal|, respectively.\n             • win: |window-ID|. Used for setting window local\n               option.\n             • buf: Buffer number. Used for setting buffer\n               local option."
    },
    "doc": [
      "Sets the value of an option. The behavior of this function\nmatches that of |:set|: for global-local options, both the\nglobal and local value are set unless otherwise specified with\n{scope}.",
      "Note the options {win} and {buf} cannot be used together."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_set_var": {
    "annotations": [],
    "signature": "nvim_set_var({name}, {value}, {err})",
    "parameters": [
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Variable name", "value": "Variable value" },
    "doc": ["Sets a global (g:) variable."],
    "return": [],
    "seealso": []
  },
  "nvim_set_vvar": {
    "annotations": [],
    "signature": "nvim_set_vvar({name}, {value}, {err})",
    "parameters": [
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "name": "Variable name", "value": "Variable value" },
    "doc": ["Sets a v: variable, if it is not readonly."],
    "return": [],
    "seealso": []
  },
  "nvim_strwidth": {
    "annotations": [],
    "signature": "nvim_strwidth({text}, {err})",
    "parameters": [
      ["String", "text"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "text": "Some text" },
    "doc": [
      "Calculates the number of display cells occupied by `text`.\nControl characters including <Tab> count as one cell."
    ],
    "return": ["Number of cells"],
    "seealso": []
  },
  "nvim_subscribe": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_subscribe({event})",
    "parameters": [["String", "event"]],
    "parameters_doc": { "event": "Event type string" },
    "doc": ["Subscribes to event broadcasts."],
    "return": [],
    "seealso": []
  },
  "nvim_tabpage_del_var": {
    "annotations": [],
    "signature": "nvim_tabpage_del_var({tabpage}, {name}, {err})",
    "parameters": [
      ["Tabpage", "tabpage"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "tabpage": "Tabpage handle, or 0 for current tabpage",
      "name": "Variable name"
    },
    "doc": ["Removes a tab-scoped (t:) variable"],
    "return": [],
    "seealso": []
  },
  "nvim_tabpage_get_number": {
    "annotations": [],
    "signature": "nvim_tabpage_get_number({tabpage}, {err})",
    "parameters": [
      ["Tabpage", "tabpage"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "tabpage": "Tabpage handle, or 0 for current tabpage" },
    "doc": ["Gets the tabpage number"],
    "return": ["Tabpage number"],
    "seealso": []
  },
  "nvim_tabpage_get_var": {
    "annotations": [],
    "signature": "nvim_tabpage_get_var({tabpage}, {name}, {err})",
    "parameters": [
      ["Tabpage", "tabpage"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "tabpage": "Tabpage handle, or 0 for current tabpage",
      "name": "Variable name"
    },
    "doc": ["Gets a tab-scoped (t:) variable"],
    "return": ["Variable value"],
    "seealso": []
  },
  "nvim_tabpage_get_win": {
    "annotations": [],
    "signature": "nvim_tabpage_get_win({tabpage}, {err})",
    "parameters": [
      ["Tabpage", "tabpage"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "tabpage": "Tabpage handle, or 0 for current tabpage" },
    "doc": ["Gets the current window in a tabpage"],
    "return": ["Window handle"],
    "seealso": []
  },
  "nvim_tabpage_is_valid": {
    "annotations": [],
    "signature": "nvim_tabpage_is_valid({tabpage})",
    "parameters": [["Tabpage", "tabpage"]],
    "parameters_doc": { "tabpage": "Tabpage handle, or 0 for current tabpage" },
    "doc": ["Checks if a tabpage is valid"],
    "return": ["true if the tabpage is valid, false otherwise"],
    "seealso": []
  },
  "nvim_tabpage_list_wins": {
    "annotations": [],
    "signature": "nvim_tabpage_list_wins({tabpage}, {err})",
    "parameters": [
      ["Tabpage", "tabpage"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "tabpage": "Tabpage handle, or 0 for current tabpage" },
    "doc": ["Gets the windows in a tabpage"],
    "return": ["List of windows in `tabpage`"],
    "seealso": []
  },
  "nvim_tabpage_set_var": {
    "annotations": [],
    "signature": "nvim_tabpage_set_var({tabpage}, {name}, {value}, {err})",
    "parameters": [
      ["Tabpage", "tabpage"],
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "tabpage": "Tabpage handle, or 0 for current tabpage",
      "name": "Variable name",
      "value": "Variable value"
    },
    "doc": ["Sets a tab-scoped (t:) variable"],
    "return": [],
    "seealso": []
  },
  "nvim_ui_attach": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_ui_attach({width}, {height}, {options}, {err})",
    "parameters": [
      ["Integer", "width"],
      ["Integer", "height"],
      ["Dictionary", "options"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "width": "Requested screen columns",
      "height": "Requested screen rows",
      "options": "|ui-option| map"
    },
    "doc": [
      "Activates UI events on the channel.",
      "Entry point of all UI clients. Allows |--embed| to continue\nstartup. Implies that the client is ready to show the UI. Adds\nthe client to the list of UIs. |nvim_list_uis()|",
      "\nNote:\n    If multiple UI clients are attached, the global screen\n    dimensions degrade to the smallest client. E.g. if client\n    A requests 80x40 but client B requests 200x100, the global\n    screen has size 80x40.\n"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_ui_detach": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_ui_detach({err})",
    "parameters": [["Error *", "err"]],
    "parameters_doc": {},
    "doc": [
      "Deactivates UI events on the channel.",
      "Removes the client from the list of UIs. |nvim_list_uis()|"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_ui_pum_set_bounds": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_ui_pum_set_bounds({width}, {height}, {row}, {col}, {err})",
    "parameters": [
      ["Float", "width"],
      ["Float", "height"],
      ["Float", "row"],
      ["Float", "col"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "width": "Popupmenu width.",
      "height": "Popupmenu height.",
      "row": "Popupmenu row.",
      "col": "Popupmenu height."
    },
    "doc": [
      "Tells Nvim the geometry of the popumenu, to align floating\nwindows with an external popup menu.",
      "Note that this method is not to be confused with\n|nvim_ui_pum_set_height()|, which sets the number of visible\nitems in the popup menu, while this function sets the bounding\nbox of the popup menu, including visual elements such as\nborders and sliders. Floats need not use the same font size,\nnor be anchored to exact grid corners, so one can set\nfloating-point numbers to the popup menu geometry."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_ui_pum_set_height": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_ui_pum_set_height({height}, {err})",
    "parameters": [
      ["Integer", "height"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "height": "Popupmenu height, must be greater than zero." },
    "doc": [
      "Tells Nvim the number of elements displaying in the popumenu,\nto decide <PageUp> and <PageDown> movement."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_ui_set_option": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_ui_set_option({name}, {value}, {error})",
    "parameters": [
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "error"]
    ],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim_ui_try_resize": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_ui_try_resize({width}, {height}, {err})",
    "parameters": [
      ["Integer", "width"],
      ["Integer", "height"],
      ["Error *", "err"]
    ],
    "parameters_doc": {},
    "doc": [],
    "return": [],
    "seealso": []
  },
  "nvim_ui_try_resize_grid": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_ui_try_resize_grid({grid}, {width}, {height}, {err})",
    "parameters": [
      ["Integer", "grid"],
      ["Integer", "width"],
      ["Integer", "height"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "grid": "The handle of the grid to be changed.",
      "width": "The new requested width.",
      "height": "The new requested height."
    },
    "doc": [
      "Tell Nvim to resize a grid. Triggers a grid_resize event with\nthe requested grid size or the maximum size if it exceeds size\nlimits.",
      "On invalid grid handle, fails with error."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_unsubscribe": {
    "annotations": ["|RPC| only"],
    "signature": "nvim_unsubscribe({event})",
    "parameters": [["String", "event"]],
    "parameters_doc": { "event": "Event type string" },
    "doc": ["Unsubscribes to event broadcasts."],
    "return": [],
    "seealso": []
  },
  "nvim_win_call": {
    "annotations": ["|vim.api| only"],
    "signature": "nvim_win_call({window}, {fun}, {err})",
    "parameters": [
      ["Window", "window"],
      ["LuaRef", "fun"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "fun": "Function to call inside the window (currently\n              lua callable only)"
    },
    "doc": ["Calls a function with window as temporary current window."],
    "return": [
      "Return value of function. NB: will deepcopy lua values\n    currently, use upvalues to send lua references in and out."
    ],
    "seealso": ["|win_execute()|", "|nvim_buf_call()|"]
  },
  "nvim_win_close": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_win_close({window}, {force}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Boolean", "force"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "force": "Behave like `:close!` The last window of a\n              buffer with unwritten changes can be closed. The\n              buffer will become hidden, even if 'hidden' is\n              not set."
    },
    "doc": ["Closes the window (like |:close| with a |window-ID|)."],
    "return": [],
    "seealso": []
  },
  "nvim_win_del_var": {
    "annotations": [],
    "signature": "nvim_win_del_var({window}, {name}, {err})",
    "parameters": [
      ["Window", "window"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "name": "Variable name"
    },
    "doc": ["Removes a window-scoped (w:) variable"],
    "return": [],
    "seealso": []
  },
  "nvim_win_get_buf": {
    "annotations": [],
    "signature": "nvim_win_get_buf({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": ["Gets the current buffer in a window"],
    "return": ["Buffer handle"],
    "seealso": []
  },
  "nvim_win_get_config": {
    "annotations": [],
    "signature": "nvim_win_get_config({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": [
      "Gets window configuration.",
      "The returned value may be given to |nvim_open_win()|.",
      "`relative` is empty for normal windows."
    ],
    "return": ["Map defining the window configuration, see\n    |nvim_open_win()|"],
    "seealso": []
  },
  "nvim_win_get_cursor": {
    "annotations": [],
    "signature": "nvim_win_get_cursor({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": ["Gets the (1,0)-indexed cursor position in the window.\n|api-indexing|"],
    "return": ["(row, col) tuple"],
    "seealso": []
  },
  "nvim_win_get_height": {
    "annotations": [],
    "signature": "nvim_win_get_height({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": ["Gets the window height"],
    "return": ["Height as a count of rows"],
    "seealso": []
  },
  "nvim_win_get_number": {
    "annotations": [],
    "signature": "nvim_win_get_number({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": ["Gets the window number"],
    "return": ["Window number"],
    "seealso": []
  },
  "nvim_win_get_option": {
    "annotations": [],
    "signature": "nvim_win_get_option({window}, {name}, {err})",
    "parameters": [
      ["Window", "window"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "name": "Option name"
    },
    "doc": ["Gets a window option value"],
    "return": ["Option value"],
    "seealso": []
  },
  "nvim_win_get_position": {
    "annotations": [],
    "signature": "nvim_win_get_position({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": ["Gets the window position in display cells. First position is\nzero."],
    "return": ["(row, col) tuple with the window position"],
    "seealso": []
  },
  "nvim_win_get_tabpage": {
    "annotations": [],
    "signature": "nvim_win_get_tabpage({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": ["Gets the window tabpage"],
    "return": ["Tabpage that contains the window"],
    "seealso": []
  },
  "nvim_win_get_var": {
    "annotations": [],
    "signature": "nvim_win_get_var({window}, {name}, {err})",
    "parameters": [
      ["Window", "window"],
      ["String", "name"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "name": "Variable name"
    },
    "doc": ["Gets a window-scoped (w:) variable"],
    "return": ["Variable value"],
    "seealso": []
  },
  "nvim_win_get_width": {
    "annotations": [],
    "signature": "nvim_win_get_width({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": ["Gets the window width"],
    "return": ["Width as a count of columns"],
    "seealso": []
  },
  "nvim_win_hide": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_win_hide({window}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Error *", "err"]
    ],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": [
      "Closes the window and hide the buffer it contains (like\n|:hide| with a |window-ID|).",
      "Like |:hide| the buffer becomes hidden unless another window\nis editing it, or 'bufhidden' is `unload`, `delete` or `wipe`\nas opposed to |:close| or |nvim_win_close|, which will close\nthe buffer."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_win_is_valid": {
    "annotations": [],
    "signature": "nvim_win_is_valid({window})",
    "parameters": [["Window", "window"]],
    "parameters_doc": { "window": "Window handle, or 0 for current window" },
    "doc": ["Checks if a window is valid"],
    "return": ["true if the window is valid, false otherwise"],
    "seealso": []
  },
  "nvim_win_set_buf": {
    "annotations": ["not allowed when |textlock| is active"],
    "signature": "nvim_win_set_buf({window}, {buffer}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Buffer", "buffer"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "buffer": "Buffer handle"
    },
    "doc": ["Sets the current buffer in a window, without side effects"],
    "return": [],
    "seealso": []
  },
  "nvim_win_set_config": {
    "annotations": [],
    "signature": "nvim_win_set_config({window}, {config}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Dict(float_config) *", "config"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "config": "Map defining the window configuration, see\n              |nvim_open_win()|"
    },
    "doc": [
      "Configures window layout. Currently only for floating and\nexternal windows (including changing a split window to those\nlayouts).",
      "When reconfiguring a floating window, absent option keys will\nnot be changed. `row`/`col` and `relative` must be\nreconfigured together."
    ],
    "return": [],
    "seealso": ["|nvim_open_win()|"]
  },
  "nvim_win_set_cursor": {
    "annotations": [],
    "signature": "nvim_win_set_cursor({window}, {pos}, {err})",
    "parameters": [
      ["Window", "window"],
      ["ArrayOf(Integer, 2)", "pos"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "pos": "(row, col) tuple representing the new position"
    },
    "doc": [
      "Sets the (1,0)-indexed cursor position in the window.\n|api-indexing| This scrolls the window even if it is not the\ncurrent one."
    ],
    "return": [],
    "seealso": []
  },
  "nvim_win_set_height": {
    "annotations": [],
    "signature": "nvim_win_set_height({window}, {height}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Integer", "height"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "height": "Height as a count of rows"
    },
    "doc": ["Sets the window height."],
    "return": [],
    "seealso": []
  },
  "nvim_win_set_option": {
    "annotations": [],
    "signature": "nvim_win_set_option({window}, {name}, {value}, {err})",
    "parameters": [
      ["Window", "window"],
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "name": "Option name",
      "value": "Option value"
    },
    "doc": [
      "Sets a window option value. Passing 'nil' as value deletes the\noption(only works if there's a global fallback)"
    ],
    "return": [],
    "seealso": []
  },
  "nvim_win_set_var": {
    "annotations": [],
    "signature": "nvim_win_set_var({window}, {name}, {value}, {err})",
    "parameters": [
      ["Window", "window"],
      ["String", "name"],
      ["Object", "value"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "name": "Variable name",
      "value": "Variable value"
    },
    "doc": ["Sets a window-scoped (w:) variable"],
    "return": [],
    "seealso": []
  },
  "nvim_win_set_width": {
    "annotations": [],
    "signature": "nvim_win_set_width({window}, {width}, {err})",
    "parameters": [
      ["Window", "window"],
      ["Integer", "width"],
      ["Error *", "err"]
    ],
    "parameters_doc": {
      "window": "Window handle, or 0 for current window",
      "width": "Width as a count of columns"
    },
    "doc": [
      "Sets the window width. This will only succeed if the screen is\nsplit vertically."
    ],
    "return": [],
    "seealso": []
  }
}
